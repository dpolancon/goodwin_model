r_d     <- rpart$r_d
Z_omega <- rpart$Z_omega
Z_d     <- rpart$Z_d
J12 <- e * g_r * r_omega
J13 <- e * g_r * r_d
J21 <- omega * par$phi1
J22 <- omega * (-par$phi2 * Z_omega)
J23 <- omega * (-par$phi2 * Z_d)
J32 <- 1 + r_omega * (kap_r - d * g_r)
J33 <- kap_r * r_d + par$i - ss$g_n - d * g_r * r_d
J <- matrix(c(
0,   J12, J13,
J21, J22, J23,
0,   J32, J33
), nrow=3, byrow=TRUE)
list(J=J,
aux=list(r=r, kap_r=kap_r, g_r=g_r,
Z=rpart$Z, f=rpart$f, denom=ss$denom,
Z_omega=Z_omega, Z_d=Z_d))
}
rh_hopf_3x3 <- function(J) {
a1 <- -sum(diag(J))
a2 <- det(J[-1,-1]) + det(J[-2,-2]) + det(J[-3,-3])
a3 <- -det(J)
H  <- a1*a2 - a3
stable_RH <- (a1 > 0) && (a2 > 0) && (a3 > 0) && (H > 0)
list(a1=a1, a2=a2, a3=a3, H=H, stable_RH=stable_RH)
}
analyze_at_par <- function(par, denom_eps=1e-6) {
ss <- steady_state_reduced3D(par, denom_eps=denom_eps)
if (!isTRUE(ss$ok)) return(ss)
Jp <- jacobian_reduced3D_at_ss(ss, ss$par)
rh <- rh_hopf_3x3(Jp$J)
eig <- eigen(Jp$J)$values
list(ok=TRUE, ss=ss, J=Jp$J, rh=rh, eigenvalues=eig, aux=Jp$aux)
}
## -----------------------------
## 4) Hopf scan over rF_bar
## -----------------------------
hopf_scan <- function(par,
rF_bar_grid = seq(0.005, 0.20, by=0.001),
denom_eps = 1e-6) {
par <- normalize_par(par)
Hvals <- rep(NA_real_, length(rF_bar_grid))
a1v   <- rep(NA_real_, length(rF_bar_grid))
a2v   <- rep(NA_real_, length(rF_bar_grid))
a3v   <- rep(NA_real_, length(rF_bar_grid))
okRH  <- rep(FALSE, length(rF_bar_grid))
for (j in seq_along(rF_bar_grid)) {
par$rF_bar <- rF_bar_grid[j]
out <- analyze_at_par(par, denom_eps=denom_eps)
if (!isTRUE(out$ok)) next
rh <- out$rh
if (rh$a1 > 0 && rh$a2 > 0 && rh$a3 > 0) {
Hvals[j] <- rh$H
a1v[j] <- rh$a1; a2v[j] <- rh$a2; a3v[j] <- rh$a3
okRH[j] <- TRUE
}
}
idx <- which(okRH & is.finite(Hvals))
roots <- tibble(lower=numeric(0), upper=numeric(0), root=numeric(0))
if (length(idx) >= 2) {
for (k in 2:length(idx)) {
i1 <- idx[k-1]; i2 <- idx[k]
H1 <- Hvals[i1]; H2 <- Hvals[i2]
if (is.finite(H1) && is.finite(H2) && H1*H2 < 0) {
a <- rF_bar_grid[i1]; b <- rF_bar_grid[i2]
fH <- function(rFbar) {
par2 <- par
par2$rF_bar <- rFbar
out2 <- analyze_at_par(par2, denom_eps=denom_eps)
if (!isTRUE(out2$ok)) return(NA_real_)
rh2 <- out2$rh
if (!(rh2$a1 > 0 && rh2$a2 > 0 && rh2$a3 > 0)) return(NA_real_)
rh2$H
}
Ha <- fH(a); Hb <- fH(b)
if (is.finite(Ha) && is.finite(Hb) && Ha*Hb < 0) {
rt <- uniroot(fH, lower=a, upper=b)$root
roots <- bind_rows(roots, tibble(lower=a, upper=b, root=rt))
}
}
}
}
list(grid=rF_bar_grid, H=Hvals, a1=a1v, a2=a2v, a3=a3v, okRH=okRH, roots=roots)
}
## -----------------------------
## 5) RHS + simulation (with denom guard)
## -----------------------------
rhs_reduced3D <- function(t, state, par) {
par <- normalize_par(par)
e <- state[["e"]]
w <- state[["omega"]]
d <- state[["d"]]
d_floor <- if (!is.null(par$d_floor)) par$d_floor else 1e-9
denom_floor <- if (!is.null(par$denom_floor)) par$denom_floor else 1e-3
d_safe  <- max(d, d_floor)
e_safe  <- min(max(e, 1e-9), 1 - 1e-9)
w_safe  <- min(max(w, 1e-9), 1 - 1e-9)
r <- r_fun(w_safe, d_safe, par)
kap <- kappa_fun(r, par)
g   <- kap / par$sigma - par$delta
g_n <- par$alpha + par$beta
th  <- theta_fun(r, par)
lam <- lambda_tilt_fun(r, par)
den <- par$rF_bar - par$tau_F - g
# Hard safety: if denom is near 0, stop producing fake dynamics
if (!is.finite(den) || abs(den) < denom_floor) {
return(list(
c(NA_real_, NA_real_, NA_real_),
c(r=r, kappa=kap, g=g, g_n=g_n, theta=th, lambda_tilt=lam,
denom=den, f=NA_real_, Ztilde=NA_real_, y_pc=NA_real_)
))
}
f   <- - (lam * (1 - th) * r) / den
Zt  <- Z_fun(d_safe, f, par)
de <- (g - g_n) * e_safe
dw <- w_safe * (par$phi0 + par$phi1 * e_safe - par$alpha - par$phi2 * Zt)
dd <- kap - (1 - w_safe) + par$i * d_safe - d_safe * g
if (d <= d_floor && dd < 0) dd <- 0
y_pc <- exp(par$alpha * t) * e_safe
list(
c(de, dw, dd),
c(r=r, kappa=kap, g=g, g_n=g_n, theta=th, lambda_tilt=lam,
denom=den, f=f, Ztilde=Zt, y_pc=y_pc)
)
}
simulate_model <- function(par, state0=NULL,
t_end=500, dt=0.05,
perturb=c(e=0.002, omega=-0.002, d=0.02)) {
par <- normalize_par(par)
if (is.null(state0)) {
ss <- steady_state_reduced3D(par)
if (!isTRUE(ss$ok)) stop("No admissible steady state: ", ss$reason)
state0 <- make_state0_from_ss(ss, perturb=perturb)
}
times <- seq(0, t_end, by=dt)
sol <- ode(
y = state0,
times = times,
func = rhs_reduced3D,
parms = par,
method = "lsoda"
)
df <- as.data.frame(sol) |>
as_tibble() |>
mutate(
y_pc_0 = if ("y_pc" %in% names(.)) first(y_pc) else NA_real_,
y_pc_norm = if ("y_pc" %in% names(.)) y_pc / y_pc_0 else NA_real_
)
df
}
## -----------------------------
## 6) Plotting
## -----------------------------
plot_states <- function(df, tag, out_dir="outputs") {
p <- df |>
select(time, e, omega, d) |>
pivot_longer(-time, names_to="var", values_to="value") |>
ggplot(aes(x=time, y=value)) +
geom_line() +
facet_wrap(~var, scales="free_y", ncol=1) +
labs(title=paste0("States over time (", tag, ")"), x="t", y=NULL)
ggsave(file.path(out_dir, paste0("states_", tag, ".png")),
p, width=7, height=7, dpi=160)
p
}
plot_finance <- function(df, tag, out_dir="outputs") {
p <- df |>
select(time, r, kappa, g, theta, lambda_tilt, denom, f, Ztilde) |>
pivot_longer(-time, names_to="var", values_to="value") |>
ggplot(aes(x=time, y=value)) +
geom_line() +
facet_wrap(~var, scales="free_y", ncol=1) +
labs(title=paste0("Finance/discipline block (", tag, ")"), x="t", y=NULL)
ggsave(file.path(out_dir, paste0("finance_", tag, ".png")),
p, width=7, height=9, dpi=160)
p
}
plot_phases <- function(df, tag, out_dir="outputs") {
p1 <- ggplot(df, aes(x=e, y=omega)) + geom_path() +
labs(title=paste0("Phase: e–omega (", tag, ")"), x="e", y="omega")
p2 <- ggplot(df, aes(x=omega, y=d)) + geom_path() +
labs(title=paste0("Phase: omega–d (", tag, ")"), x="omega", y="d")
p3 <- ggplot(df, aes(x=e, y=d)) + geom_path() +
labs(title=paste0("Phase: e–d (", tag, ")"), x="e", y="d")
ggsave(file.path(out_dir, paste0("phase_e_omega_", tag, ".png")), p1, width=6, height=4, dpi=160)
ggsave(file.path(out_dir, paste0("phase_omega_d_", tag, ".png")), p2, width=6, height=4, dpi=160)
ggsave(file.path(out_dir, paste0("phase_e_d_", tag, ".png")), p3, width=6, height=4, dpi=160)
invisible(list(e_omega=p1, omega_d=p2, e_d=p3))
}
plot_3d_traj <- function(df, tag, out_dir="outputs", thin=5) {
df2 <- df |> slice(seq(1, n(), by=thin))
png(file.path(out_dir, paste0("traj3d_", tag, ".png")), width=900, height=700)
scatterplot3d(df2$e, df2$omega, df2$d,
type="l",
xlab="e", ylab="omega", zlab="d",
main=paste0("3D trajectory (", tag, ")"))
dev.off()
invisible(TRUE)
}
## -----------------------------
## 7) Dynamics classifier (improved)
## -----------------------------
classify_dynamics <- function(df, tail_frac=0.25, sd_fp=5e-4, sd_persist=5e-3) {
n <- nrow(df)
i0 <- max(1, floor((1 - tail_frac) * n))
tail <- df[i0:n, , drop=FALSE]
eps <- 1e-6
hit_e     <- any(tail$e <= 0 + eps | tail$e >= 1 - eps, na.rm=TRUE)
hit_omega <- any(tail$omega <= 0 + eps | tail$omega >= 1 - eps, na.rm=TRUE)
hit_d0    <- any(tail$d <= 0 + eps, na.rm=TRUE)
sd_e <- sd(tail$e, na.rm=TRUE)
sd_w <- sd(tail$omega, na.rm=TRUE)
sd_d <- sd(tail$d, na.rm=TRUE)
sd_max <- max(sd_e, sd_w, sd_d)
half <- floor(nrow(tail)/2)
tail1 <- tail[1:half, , drop=FALSE]
tail2 <- tail[(half+1):nrow(tail), , drop=FALSE]
amp1 <- max(abs(tail1$omega - mean(tail1$omega, na.rm=TRUE)), na.rm=TRUE)
amp2 <- max(abs(tail2$omega - mean(tail2$omega, na.rm=TRUE)), na.rm=TRUE)
amp_ratio <- if (is.finite(amp1) && amp1 > 0) amp2 / amp1 else NA_real_
if (hit_e || hit_omega || hit_d0) {
cls <- "boundary_crash_or_clamp"
} else if (is.finite(sd_max) && sd_max < sd_fp) {
cls <- "fixed_point_convergence"
} else if (is.finite(sd_max) && sd_max > sd_persist) {
cls <- "persistent_cycle_or_transient"
} else if (is.finite(amp_ratio) && amp_ratio > 1.1) {
cls <- "diverging_oscillation"
} else if (is.finite(amp_ratio) && amp_ratio < 0.9) {
cls <- "damped_oscillation"
} else {
cls <- "limit_cycle_or_neutral"
}
tibble(
tail_sd_e = sd_e, tail_sd_omega = sd_w, tail_sd_d = sd_d,
amp_ratio = amp_ratio,
hit_bounds = hit_e || hit_omega || hit_d0,
class = cls
)
}
## -----------------------------
## 8) NEW: omega* targeting (calibration tuner)
## -----------------------------
omega_target_sweep <- function(par,
omega_target = c(0.60, 0.70),
kappa_r0_grid = seq(0.005, 0.060, by=0.0025),
kappa_lambda_grid = c(12, 15, 20),
sigma_grid = c(3.0, 2.75, 2.5),
i_grid = c(0.04, 0.0375, 0.035),
denom_eps = 1e-6,
denom_ok = 1e-3) {
par <- normalize_par(par)
out <- tibble()
for (sig in sigma_grid) {
for (i0 in i_grid) {
for (lam in kappa_lambda_grid) {
for (r0 in kappa_r0_grid) {
par2 <- par
par2$sigma <- sig
par2$i <- i0
par2$kappa_lambda <- lam
par2$kappa_r0 <- r0
ss <- steady_state_reduced3D(par2, denom_eps=denom_eps)
if (!isTRUE(ss$ok)) next
out <- bind_rows(out, tibble(
sigma=sig, i=i0, kappa_lambda=lam, kappa_r0=r0,
omega_star=ss$omega, e_star=ss$e, d_star=ss$d, r_star=ss$r,
denom_star=ss$denom
))
}
}
}
}
mid <- mean(omega_target)
out |>
mutate(
omega_in_band = omega_star >= omega_target[1] & omega_star <= omega_target[2],
denom_safe = abs(denom_star) > denom_ok,
obj = abs(omega_star - mid) +
0.05 * pmax(0, 1/abs(denom_star) - 1/denom_ok) +   # penalize denom danger
0.001 * pmax(0, d_star - 5)                        # penalize silly debt
) |>
arrange(desc(omega_in_band), desc(denom_safe), obj)
}
apply_damping_preset <- function(par,
preset = c("off","mild","strong")) {
preset <- match.arg(preset)
par <- normalize_par(par)
if (preset == "off") return(par)
if (preset == "mild") {
par$phi1 <- min(par$phi1, 0.08)
par$phi3 <- min(par$phi3, 8)
par$phi2 <- min(par$phi2, 0.02)
par$phi4 <- min(par$phi4, 0.9)
}
if (preset == "strong") {
par$phi1 <- min(par$phi1, 0.06)
par$phi3 <- min(par$phi3, 6)
par$phi2 <- min(par$phi2, 0.015)
par$phi4 <- min(par$phi4, 0.7)
}
par
}
## -----------------------------
## 9) Bundle runner (with optional omega tuning)
## -----------------------------
run_bundle <- function(par,
out_dir="outputs/reduced3D",
t_end=500, dt=0.05,
hopf_grid=seq(0.005, 0.20, by=0.001),
hopf_eps=0.002,
denom_eps=1e-6,
common_state0=TRUE,
perturb=c(e=0.002, omega=-0.002, d=0.02),
tune_omega = TRUE,
omega_target = c(0.60, 0.70),
damping_preset = c("off","mild","strong")) {
damping_preset <- match.arg(damping_preset)
par <- normalize_par(par)
dir_create(out_dir)
writeLines(capture.output(sessionInfo()), file.path(out_dir, "sessionInfo.txt"))
# Optional: apply damping preset (amplitude control)
par <- apply_damping_preset(par, damping_preset)
# Optional: tune omega* band (level control)
tuned <- NULL
if (isTRUE(tune_omega)) {
cand <- omega_target_sweep(par, omega_target=omega_target, denom_eps=denom_eps)
write.csv(cand, file.path(out_dir, "omega_target_candidates.csv"), row.names=FALSE)
if (nrow(cand) == 0) stop("No admissible candidates found for omega targeting sweep.")
best <- cand[1,]
par$sigma <- best$sigma
par$i <- best$i
par$kappa_lambda <- best$kappa_lambda
par$kappa_r0 <- best$kappa_r0
tuned <- best
write.csv(best, file.path(out_dir, "omega_target_best.csv"), row.names=FALSE)
}
# Baseline analysis
base <- analyze_at_par(par, denom_eps=denom_eps)
if (!isTRUE(base$ok)) stop("Baseline inadmissible after tuning: ", base$reason)
ss_tbl <- tibble(
e=base$ss$e, omega=base$ss$omega, d=base$ss$d,
r=base$ss$r, kappa=base$ss$kappa, g=base$ss$g, g_n=base$ss$g_n,
denom=base$ss$denom,
theta=base$ss$theta, lambda_tilt=base$ss$lambda_tilt,
f=base$ss$f, Z=base$ss$Z,
rF_bar=par$rF_bar, rF_tilde=par$rF_tilde, tau_F=par$tau_F,
tuned = !is.null(tuned),
damping = damping_preset
)
write.csv(ss_tbl, file.path(out_dir, "steady_state.csv"), row.names=FALSE)
write.csv(tibble(a1=base$rh$a1, a2=base$rh$a2, a3=base$rh$a3, H=base$rh$H, stable_RH=base$rh$stable_RH),
file.path(out_dir, "rh_hopf.csv"), row.names=FALSE)
write.csv(tibble(eigen_real=Re(base$eigenvalues), eigen_imag=Im(base$eigenvalues)),
file.path(out_dir, "eigenvalues.csv"), row.names=FALSE)
# Hopf scan
scan <- hopf_scan(par, rF_bar_grid=hopf_grid, denom_eps=denom_eps)
scan_tbl <- tibble(rF_bar=scan$grid, H=scan$H, a1=scan$a1, a2=scan$a2, a3=scan$a3, okRH=scan$okRH)
write.csv(scan_tbl, file.path(out_dir, "hopf_scan.csv"), row.names=FALSE)
write.csv(scan$roots, file.path(out_dir, "hopf_roots.csv"), row.names=FALSE)
pH <- ggplot(scan_tbl |> filter(okRH, is.finite(H)), aes(x=rF_bar, y=H)) +
geom_line() + geom_hline(yintercept=0) +
labs(title="Hopf functional H over rF_bar (RH-positive region)", x="rF_bar", y="H")
ggsave(file.path(out_dir, "hopf_H_curve.png"), pH, width=7, height=4, dpi=160)
# Build regimes
pars_list <- list(baseline = par)
if (nrow(scan$roots) >= 1) {
r1 <- scan$roots$root[1]
pars_list$below_root1 <- modifyList(par, list(rF_bar = r1 - hopf_eps))
pars_list$above_root1 <- modifyList(par, list(rF_bar = r1 + hopf_eps))
}
if (nrow(scan$roots) >= 2) {
r1 <- scan$roots$root[1]
r2 <- scan$roots$root[2]
pars_list$between_roots <- modifyList(par, list(rF_bar = 0.5*(r1 + r2)))
pars_list$above_root2   <- modifyList(par, list(rF_bar = r2 + hopf_eps))
}
# Common initial condition
state0_ref <- NULL
ref_tag <- NULL
if (common_state0) {
if (!is.null(pars_list$between_roots)) {
out_ref <- analyze_at_par(pars_list$between_roots, denom_eps=denom_eps)
if (isTRUE(out_ref$ok)) {
state0_ref <- make_state0_from_ss(out_ref$ss, perturb=perturb)
ref_tag <- "between_roots"
}
}
if (is.null(state0_ref)) {
state0_ref <- make_state0_from_ss(base$ss, perturb=perturb)
ref_tag <- "baseline"
}
}
# Regime runs
regime_summary <- tibble(
tag=character(), rF_bar=numeric(), ok=logical(),
H=numeric(), a1=numeric(), a2=numeric(), a3=numeric(), stable_RH=logical(),
tail_sd_e=numeric(), tail_sd_omega=numeric(), tail_sd_d=numeric(),
amp_ratio=numeric(), hit_bounds=logical(), class=character()
)
for (tg in names(pars_list)) {
par_t <- normalize_par(pars_list[[tg]])
out_t <- analyze_at_par(par_t, denom_eps=denom_eps)
if (!isTRUE(out_t$ok)) {
regime_summary <- bind_rows(regime_summary, tibble(
tag=tg, rF_bar=par_t$rF_bar, ok=FALSE,
H=NA_real_, a1=NA_real_, a2=NA_real_, a3=NA_real_, stable_RH=FALSE,
tail_sd_e=NA_real_, tail_sd_omega=NA_real_, tail_sd_d=NA_real_,
amp_ratio=NA_real_, hit_bounds=NA, class=NA_character_
))
next
}
df <- simulate_model(
par_t,
state0 = if (common_state0) state0_ref else NULL,
t_end = t_end, dt = dt,
perturb = perturb
)
# If denom guard triggered, you'll see NA derivatives leak into output
# Mark it explicitly
bad <- any(!is.finite(df$e) | !is.finite(df$omega) | !is.finite(df$d), na.rm=TRUE)
if (!bad) {
write.csv(df, file.path(out_dir, paste0("sim_", tg, ".csv")), row.names=FALSE)
plot_states(df, tg, out_dir)
plot_finance(df, tg, out_dir)
plot_phases(df, tg, out_dir)
plot_3d_traj(df, tg, out_dir, thin=5)
} else {
write.csv(df, file.path(out_dir, paste0("sim_", tg, "_INVALID.csv")), row.names=FALSE)
}
cls <- classify_dynamics(df)
rh <- out_t$rh
regime_summary <- bind_rows(regime_summary, tibble(
tag=tg, rF_bar=par_t$rF_bar, ok=TRUE,
H=rh$H, a1=rh$a1, a2=rh$a2, a3=rh$a3, stable_RH=rh$stable_RH,
tail_sd_e=cls$tail_sd_e, tail_sd_omega=cls$tail_sd_omega, tail_sd_d=cls$tail_sd_d,
amp_ratio=cls$amp_ratio, hit_bounds=cls$hit_bounds, class=cls$class
))
}
write.csv(regime_summary, file.path(out_dir, "regime_summary.csv"), row.names=FALSE)
print(regime_summary)
# README
readme <- c(
"# Reduced 3D Goodwin–Minsky (quasi-steady financialization) bundle",
"",
"## What you get",
"- steady_state.csv: interior SS with admissibility",
"- rh_hopf.csv + eigenvalues.csv",
"- hopf_scan.csv + hopf_roots.csv + hopf_H_curve.png",
"- sim_<tag>.csv and plots per regime (states/finance/phases/3d)",
"- regime_summary.csv with RH + tail behavior classification",
"",
paste0("## omega* targeting: ", tune_omega, " (target band: [", omega_target[1], ", ", omega_target[2], "])"),
paste0("## damping preset: ", damping_preset),
paste0("## common_state0: ", common_state0, " (ref_tag=", ref_tag, ")")
)
writeLines(readme, file.path(out_dir, "README.md"))
invisible(list(base=base, scan=scan, regimes=regime_summary,
state0_ref=state0_ref, ref_tag=ref_tag,
tuned=tuned, par_final=par))
}
############################################################
## 10) Baseline parameters
############################################################
par <- list(
# macro
alpha = 0.02, beta = 0.01,
delta = 0.02, sigma = 3,
i = 0.04,
# investment logistic (these will be tuned if tune_omega=TRUE)
kappa_min = 0.00, kappa_max = 0.30,
kappa_lambda = 20, kappa_r0 = 0.04,
# wage dynamics
phi0 = -0.06, phi1 = 0.10,
# discipline
phi2 = 0.02,   # intensity
phi3 = 10,     # steepness
phi4 = 1.0,    # loading on (f-1)
# financialization sweep lever
rF_bar = 0.08,
rF_tilde = 0.06,
tau_F = 0.01,
# payout theta(r)
theta_min = 0.10, theta_max = 0.90,
theta_k = 20, theta_0 = 0.00,
# portfolio tilt lambda(r)
lam_min = 0.10, lam_max = 0.90,
lam_k = 20, lam_0 = 0.00,
# numerics
d_floor = 1e-9,
denom_floor = 1e-3
)
############################################################
## 11) Execute
############################################################
bundle <- run_bundle(
par,
out_dir = "outputs/reduced3D_tuned",
t_end = 500,
dt = 0.05,
hopf_grid = seq(0.005, 0.20, by = 0.001),
hopf_eps = 0.002,
common_state0 = TRUE,
perturb = c(e=0.002, omega=-0.002, d=0.02),
tune_omega = TRUE,
omega_target = c(0.60, 0.70),
damping_preset = "mild"   # try "off", "mild", "strong"
)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
