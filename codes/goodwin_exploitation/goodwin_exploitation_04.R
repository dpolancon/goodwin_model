# STEP 4: Phase-dependent GIRFs (Poincare phase) for Goodwin in (e, xi)
# Option A admissibility: keep 0<e(t)<1 via invariant gate, no model change.
# Shock: eta = log(xi) -> eta + eps  (i.e., xi <- xi*exp(eps))
# Output: phase response curves for e (and optionally omega, xi)

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

# -----------------------------
# Paths
# -----------------------------
out_dir <- here::here("outputs", "exploitation_rate", "phase_dependency")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters (Cambridge saving + depreciation)
# -----------------------------
alpha <- 0.02
beta  <- 0.01
gamma <- 0.01      # dw/w = -gamma + rho e
delta <- 0.04
s_pi  <- 0.80

# target fixed point location
e_star_target     <- 0.95
omega_star_target <- 0.60

rho   <- (alpha + gamma) / e_star_target
sigma <- s_pi * (1 - omega_star_target) / (alpha + beta + delta)

A <- s_pi / sigma
B <- alpha + gamma
C <- alpha + beta + delta

q <- C / A
stopifnot(q > 0 && q < 1)

e_star  <- B / rho
xi_star <- q / (1 - q)
omega_star <- 1 / (1 + xi_star)

cat("Fixed point:\n")
cat("e*     =", e_star, "\n")
cat("omega* =", omega_star, "\n")
cat("xi*    =", xi_star, "\n\n")

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# -----------------------------
# 2) ODE model in (e, xi)
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

# -----------------------------
# 3) Option A admissibility via invariant H
# -----------------------------
H <- function(e, xi) {
  B*log(e) - rho*e - (A-C)*log(1+xi) - A/(1+xi)
}

e_turning_points <- function(H0, eps = 1e-10) {
  K <- H0 + (A - C) * log(1 + xi_star) + A / (1 + xi_star)
  F <- function(e) B * log(e) - rho * e - K
  
  e_hat <- min(max(B / rho, eps), 1 - eps)
  F_hat <- F(e_hat)
  if (!is.finite(F_hat) || F_hat <= 0) return(NULL)
  
  rL <- try(uniroot(F, c(eps, e_hat - eps))$root, silent = TRUE)
  rR <- try(uniroot(F, c(e_hat + eps, 1 - eps))$root, silent = TRUE)
  if (inherits(rL, "try-error") || inherits(rR, "try-error")) return(NULL)
  
  sort(c(rL, rR))
}

admissible_ic <- function(e0, omega0) {
  if (!is.finite(e0) || !is.finite(omega0)) return(FALSE)
  if (e0 <= 0 || e0 >= 1) return(FALSE)
  if (omega0 <= 0 || omega0 >= 1) return(FALSE)
  
  xi0 <- (1 - omega0) / omega0
  if (!is.finite(xi0) || xi0 <= 0) return(FALSE)
  
  H0 <- H(e0, xi0)
  roots <- e_turning_points(H0)
  if (is.null(roots) || length(roots) != 2) return(FALSE)
  
  list(ok = (roots[1] > 0 && roots[2] < 1), e_min=roots[1], e_max=roots[2], xi0=xi0, H0=H0)
}

shrink_kick_to_admissible <- function(e0_raw, omega0_raw, tol = 1e-6) {
  # direction of kick relative to fixed point
  de <- e0_raw - e_star
  dw <- omega0_raw - omega_star
  
  test <- function(k) admissible_ic(e_star + k*de, omega_star + k*dw)
  
  r1 <- test(1)
  if (!isFALSE(r1) && r1$ok) {
    return(c(k=1, e0=e_star+de, omega0=omega_star+dw, e_min=r1$e_min, e_max=r1$e_max))
  }
  
  lo <- 0; hi <- 1
  best_k <- NA_real_; best_r <- NULL
  for (iter in 1:70) {
    mid <- 0.5*(lo+hi)
    rm <- test(mid)
    if (!isFALSE(rm) && rm$ok) {
      best_k <- mid; best_r <- rm
      lo <- mid
    } else {
      hi <- mid
    }
    if (hi - lo < tol) break
  }
  if (is.na(best_k)) stop("No admissible non-degenerate orbit for this kick direction. Change raw IC.")
  c(k=best_k, e0=e_star+best_k*de, omega0=omega_star+best_k*dw, e_min=best_r$e_min, e_max=best_r$e_max)
}

# -----------------------------
# 4) Choose admissible baseline IC, simulate baseline orbit
# -----------------------------
e0_raw     <- 0.92
omega0_raw <- 0.56

res <- shrink_kick_to_admissible(e0_raw, omega0_raw)
print(res)
cat("Invariant e-range: [", res["e_min"], ",", res["e_max"], "]\n\n")

e0     <- unname(res["e0"])
omega0 <- unname(res["omega0"])
xi0    <- (1 - omega0) / omega0

dt <- 0.01
Tsim <- 400
times <- seq(0, Tsim, by = dt)

base <- ode(y = c(e=e0, xi=xi0), times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
base <- as.data.frame(base)
base$omega <- 1/(1+base$xi)
base$eta   <- log(base$xi)

# -----------------------------
# 5) Poincare section: upward crossings of e = e*
# -----------------------------
e_series <- base$e
t_series <- base$time

# upward crossings: e(t_i) < e* and e(t_{i+1}) >= e*
idx <- which(e_series[-length(e_series)] < e_star & e_series[-1] >= e_star)

if (length(idx) < 3) stop("Not enough Poincare crossings found. Increase Tsim or change IC amplitude.")

# interpolate crossing times (linear) + xi at crossing
crossings <- data.frame(t=NA_real_, xi=NA_real_)
for (k in seq_along(idx)) {
  i <- idx[k]
  t1 <- t_series[i]; t2 <- t_series[i+1]
  e1 <- e_series[i]; e2 <- e_series[i+1]
  w  <- (e_star - e1) / (e2 - e1)  # in (0,1)
  tc <- t1 + w*(t2 - t1)
  
  xi1 <- base$xi[i]; xi2 <- base$xi[i+1]
  xic <- xi1 + w*(xi2 - xi1)
  
  crossings[k,] <- c(tc, xic)
}

# use the last full cycle (more robust than the first)
t0 <- crossings$t[nrow(crossings)-2]
t1 <- crossings$t[nrow(crossings)-1]
Tper <- t1 - t0
cat("Estimated period (one cycle):", Tper, "\n")

# -----------------------------
# 6) Define phase points along the baseline cycle
# -----------------------------
n_phase <- 60
phase_grid <- seq(0, 2*pi, length.out = n_phase + 1)[- (n_phase + 1)]
t_phase <- t0 + (phase_grid/(2*pi))*Tper

# interpolate baseline state at those phase times
e_phase  <- approx(base$time, base$e,  xout = t_phase)$y
xi_phase <- approx(base$time, base$xi, xout = t_phase)$y

# sanity
if (any(!is.finite(e_phase)) || any(!is.finite(xi_phase))) stop("Phase interpolation failed.")
if (any(e_phase <= 0 | e_phase >= 1)) warning("Baseline phase states include e outside (0,1) (shouldn't happen).")

# -----------------------------
# 7) GIRFs: simulate baseline vs shocked from each phase state
# -----------------------------
eps_shock <- 0.02    # 2% shock in log exploitation: xi <- xi*exp(eps)
Hmax <- 30           # horizon in time units (same units as model)
dt_h <- 0.01
t_h <- seq(0, Hmax, by = dt_h)

horizons <- c(0.5, 1, 2, 5, 10, 20, 30)

simulate_forward <- function(e_init, xi_init) {
  out <- ode(y = c(e=e_init, xi=xi_init), times = t_h, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
  out <- as.data.frame(out)
  out$omega <- 1/(1+out$xi)
  out
}

# storage
girf <- expand.grid(phase = phase_grid, horizon = horizons)
girf$de <- NA_real_
girf$dxi <- NA_real_
girf$domega <- NA_real_

for (i in seq_along(phase_grid)) {
  e_init  <- e_phase[i]
  xi_init <- xi_phase[i]
  
  # baseline forward
  bwd <- simulate_forward(e_init, xi_init)
  
  # shocked forward (eta + eps => xi*exp(eps))
  xi_shock <- xi_init * exp(eps_shock)
  swd <- simulate_forward(e_init, xi_shock)
  
  # interpolate at horizons
  for (h in horizons) {
    eb <- approx(bwd$time, bwd$e, xout = h)$y
    es <- approx(swd$time, swd$e, xout = h)$y
    xb <- approx(bwd$time, bwd$xi, xout = h)$y
    xs <- approx(swd$time, swd$xi, xout = h)$y
    wb <- approx(bwd$time, bwd$omega, xout = h)$y
    ws <- approx(swd$time, swd$omega, xout = h)$y
    
    j <- which(girf$phase == phase_grid[i] & girf$horizon == h)
    girf$de[j] <- es - eb
    girf$dxi[j] <- xs - xb
    girf$domega[j] <- ws - wb
  }
}

# save data
csv_path <- file.path(out_dir, "phase_girf_etaShock.csv")
write.csv(girf, csv_path, row.names = FALSE)
cat("Saved GIRF data to:\n", csv_path, "\n")

# -----------------------------
# 8) Plots: phase response curves for e (and omega)
# -----------------------------
png_e <- file.path(out_dir, "phase_response_de.png")
pdf_e <- file.path(out_dir, "phase_response_de.pdf")

make_phase_plot <- function(var = c("de","domega"), main_prefix = "") {
  var <- match.arg(var)
  ylab <- if (var == "de") "Δe (shock - base)" else "Δomega (shock - base)"
  main <- paste0(main_prefix, "Phase-dependent GIRF (eta shock)")
  
  op <- par(mfrow = c(2,2), mar = c(3,4,2,1))
  for (h in c(1, 5, 10, 30)) {
    sub <- girf[girf$horizon == h, ]
    # order by phase for clean lines
    ord <- order(sub$phase)
    plot(sub$phase[ord], sub[[var]][ord], type="l",
         xlab = "phase (radians, Poincare-timed)", ylab = ylab,
         main = paste(main, "| horizon =", h))
    abline(h=0, lty=2)
  }
  par(op)
}

png(png_e, width=1600, height=1200, res=200)
make_phase_plot("de", main_prefix = "")
dev.off()

pdf(pdf_e, width=10, height=8)
make_phase_plot("de", main_prefix = "")
dev.off()

png_w <- file.path(out_dir, "phase_response_domega.png")
pdf_w <- file.path(out_dir, "phase_response_domega.pdf")

png(png_w, width=1600, height=1200, res=200)
make_phase_plot("domega", main_prefix = "")
dev.off()

pdf(pdf_w, width=10, height=8)
make_phase_plot("domega", main_prefix = "")
dev.off()

cat("Saved plots to:\n", png_e, "\n", pdf_e, "\n", png_w, "\n", pdf_w, "\n")
