# STEP 3: Admissible orbit + state-dependence atlas (Option A)
# - No model change. Enforce 0<e(t)<1 by admissible initial conditions via invariant H.
# - Build phase-plane atlas: nullclines + trJ=0 + detJ=0 + orbit
# - Build along-orbit diagnostics: trJ(t), detJ(t), dedxi(t), dxide(t)
# Saves to outputs/exploitation_rate/

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

out_dir <- here::here("outputs", "exploitation_rate")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters (Cambridge saving + depreciation)
# -----------------------------
alpha <- 0.02
beta  <- 0.01
gamma <- 0.01      # in dw/w = -gamma + rho*e  (gamma>0 is drag)
delta <- 0.04
s_pi  <- 0.80

# Target fixed-point location (plausible levels)
e_star_target     <- 0.95
omega_star_target <- 0.60

# Calibrate rho, sigma to hit (e*, omega*) in this closure
rho   <- (alpha + gamma) / e_star_target
sigma <- s_pi * (1 - omega_star_target) / (alpha + beta + delta)

# handy constants
A <- s_pi / sigma
B <- alpha + gamma
C <- alpha + beta + delta

# fixed point (e*, xi*)
q <- C / A
stopifnot(q > 0 && q < 1)

e_star  <- B / rho
xi_star <- q / (1 - q)
omega_star <- 1 / (1 + xi_star)

cat("Fixed point:\n")
cat("e*     =", e_star, "\n")
cat("omega* =", omega_star, "\n")
cat("xi*    =", xi_star, "\n\n")

# -----------------------------
# 2) Model in (e, xi)
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# -----------------------------
# 3) First integral H(e,xi) + admissibility gate (Option A)
# -----------------------------
H <- function(e, xi) {
  # H(e,xi)=B ln e - rho e - (A-C) ln(1+xi) - A/(1+xi)
  B*log(e) - rho*e - (A-C)*log(1+xi) - A/(1+xi)
}

e_turning_points <- function(H0, eps = 1e-10) {
  # turning points for e occur where xi = xi_star (i.e. de=0)
  K <- H0 + (A - C) * log(1 + xi_star) + A / (1 + xi_star)
  F <- function(e) B * log(e) - rho * e - K
  
  e_hat <- B / rho
  e_hat <- min(max(e_hat, eps), 1 - eps)
  
  F_hat <- F(e_hat)
  if (!is.finite(F_hat)) return(NULL)
  if (F_hat <= 0) return(NULL)  # need two roots for a non-degenerate orbit
  
  rL <- try(uniroot(F, c(eps, e_hat - eps))$root, silent = TRUE)
  rR <- try(uniroot(F, c(e_hat + eps, 1 - eps))$root, silent = TRUE)
  if (inherits(rL, "try-error") || inherits(rR, "try-error")) return(NULL)
  
  sort(c(rL, rR))
}

admissible_ic <- function(e0, omega0) {
  if (!is.finite(e0) || !is.finite(omega0)) return(FALSE)
  if (e0 <= 0 || e0 >= 1) return(FALSE)
  if (omega0 <= 0 || omega0 >= 1) return(FALSE)
  
  xi0 <- (1 - omega0) / omega0
  if (!is.finite(xi0) || xi0 <= 0) return(FALSE)
  
  H0 <- H(e0, xi0)
  roots <- e_turning_points(H0)
  if (is.null(roots) || length(roots) != 2) return(FALSE)
  
  e_min <- roots[1]
  e_max <- roots[2]
  
  list(ok = (e_min > 0 && e_max < 1),
       e_min = e_min, e_max = e_max,
       H0 = H0, xi0 = xi0)
}

shrink_kick_to_admissible <- function(e0_raw, omega0_raw, tol = 1e-6) {
  de <- e0_raw - e_star
  dw <- omega0_raw - omega_star
  
  test <- function(k) {
    e0 <- e_star + k*de
    w0 <- omega_star + k*dw
    admissible_ic(e0, w0)
  }
  
  r1 <- test(1)
  if (!isFALSE(r1) && r1$ok) {
    return(c(k=1, e0=e_star+de, omega0=omega_star+dw, e_min=r1$e_min, e_max=r1$e_max))
  }
  
  lo <- 0; hi <- 1
  best_k <- NA_real_; best_r <- NULL
  
  for (iter in 1:70) {
    mid <- 0.5*(lo+hi)
    rm <- test(mid)
    if (!isFALSE(rm) && rm$ok) {
      best_k <- mid; best_r <- rm
      lo <- mid
    } else {
      hi <- mid
    }
    if (hi - lo < tol) break
  }
  
  if (is.na(best_k)) stop("No admissible (non-degenerate) orbit found. Try a different raw IC direction.")
  
  e_best <- e_star + best_k*de
  w_best <- omega_star + best_k*dw
  c(k=best_k, e0=e_best, omega0=w_best, e_min=best_r$e_min, e_max=best_r$e_max)
}

# -----------------------------
# 4) Pick a raw kick, shrink to admissible IC, then simulate
# -----------------------------
e0_raw     <- 0.92
omega0_raw <- 0.56

res <- shrink_kick_to_admissible(e0_raw, omega0_raw)
print(res)
cat("Invariant-implied e-range: [", res["e_min"], ",", res["e_max"], "]\n\n")

e0     <- unname(res["e0"])
omega0 <- unname(res["omega0"])
xi0    <- (1 - omega0) / omega0

times <- seq(0, 400, by = 0.1)
out <- ode(y = c(e=e0, xi=xi0), times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
out <- as.data.frame(out)

# Derived variables
out$omega <- 1 / (1 + out$xi)
out$eta   <- log(out$xi)

cat("Simulated ranges:\n")
cat("e    in [", min(out$e), ",", max(out$e), "]\n")
cat("omega in [", min(out$omega), ",", max(out$omega), "]\n")
cat("xi   in [", min(out$xi), ",", max(out$xi), "]\n\n")

# -----------------------------
# 5) Jacobian along the orbit: trJ, detJ, cross-derivatives
# J =
# [ A*xi/(1+xi)-C           e*A/(1+xi)^2 ]
# [ -rho*(1+xi)             B - rho*e    ]
# -----------------------------
out$J11  <- A * out$xi/(1+out$xi) - C
out$J12  <- out$e * A / (1 + out$xi)^2
out$J21  <- -rho * (1 + out$xi)
out$J22  <- B - rho * out$e
out$trJ  <- out$J11 + out$J22
out$detJ <- out$J11*out$J22 - out$J12*out$J21

# Key state-dependent “multiplier-ish” objects
out$dedxi <- out$J12
out$dxide <- out$J21
out$minus_dxide <- -out$dxide  # positive magnitude

# Save orbit data for later (grid mapping, phase-dependent GIRFs, etc.)
csv_path <- file.path(out_dir, "step3_orbit_with_jacobian.csv")
write.csv(out, csv_path, row.names = FALSE)
cat("Saved orbit data to:\n", csv_path, "\n\n")

# -----------------------------
# 6) Phase-plane grid for trJ=0 and detJ=0 contours
# Keep e strictly in (0,1) by construction.
# -----------------------------
e_grid  <- seq(max(0.01, min(out$e)*0.90), min(0.999, max(out$e)*1.10), length.out = 220)
xi_grid <- seq(max(0.001, min(out$xi)*0.80), max(out$xi)*1.20, length.out = 220)

XI <- matrix(rep(xi_grid, times = length(e_grid)), nrow = length(xi_grid), ncol = length(e_grid))
E  <- matrix(rep(e_grid, each  = length(xi_grid)), nrow = length(xi_grid), ncol = length(e_grid))

J11g <- A * XI/(1+XI) - C
J12g <- E * A / (1+XI)^2
J21g <- -rho * (1+XI)
J22g <- B - rho * E

TRg  <- J11g + J22g
DETg <- J11g*J22g - J12g*J21g

# -----------------------------
# 7) Plots
# -----------------------------
atlas_png <- file.path(out_dir, "step3_atlas_admissible_orbit.png")
atlas_pdf <- file.path(out_dir, "step3_atlas_admissible_orbit.pdf")

diag_png  <- file.path(out_dir, "step3_along_orbit_diagnostics.png")
diag_pdf  <- file.path(out_dir, "step3_along_orbit_diagnostics.pdf")

make_atlas <- function() {
  plot(NA,
       xlim = range(xi_grid),
       ylim = range(e_grid),
       xlab = "xi (exploitation rate)",
       ylab = "e (employment rate)",
       main = "Atlas (admissible): nullclines + trJ=0 + detJ=0 + orbit")
  
  # contours
  contour(xi_grid, e_grid, TRg,  levels = 0, add = TRUE, lty = 2, drawlabels = FALSE)
  contour(xi_grid, e_grid, DETg, levels = 0, add = TRUE, lty = 3, drawlabels = FALSE)
  
  # nullclines
  abline(v = xi_star, lty = 2)
  abline(h = e_star,  lty = 2)
  
  # orbit
  lines(out$xi, out$e)
  
  legend("topright",
         legend = c("orbit", "nullclines", "trJ=0", "detJ=0"),
         lty    = c(1,2,2,3),
         bty    = "n")
}

make_diagnostics <- function() {
  op <- par(mfrow = c(4,1), mar = c(3,4,2,1))
  
  plot(out$time, out$trJ, type="l", xlab="", ylab="trJ",
       main="Along-orbit: trace of Jacobian")
  abline(h=0, lty=2)
  
  plot(out$time, out$detJ, type="l", xlab="", ylab="detJ",
       main="Along-orbit: determinant of Jacobian")
  abline(h=0, lty=2)
  
  plot(out$time, out$dedxi, type="l", xlab="", ylab="∂ė/∂xi",
       main="State dependence: ∂(de/dt)/∂xi = eA/(1+xi)^2")
  
  plot(out$time, out$minus_dxide, type="l", xlab="time", ylab="-∂ẋi/∂e",
       main="State dependence: -∂(dxi/dt)/∂e = rho(1+xi)")
  
  par(op)
}

png(atlas_png, width=1600, height=1000, res=200); make_atlas(); dev.off()
pdf(atlas_pdf, width=10, height=6); make_atlas(); dev.off()

png(diag_png, width=1600, height=1400, res=200); make_diagnostics(); dev.off()
pdf(diag_pdf, width=10, height=9); make_diagnostics(); dev.off()

cat("Saved:\n", atlas_png, "\n", atlas_pdf, "\n", diag_png, "\n", diag_pdf, "\n")
