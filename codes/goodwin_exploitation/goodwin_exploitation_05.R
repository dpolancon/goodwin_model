# STEP 4B: Phase-dependent GIRFs (Poincare phase), two shocks
# - Option A admissibility (0<e(t)<1) via invariant H (no model change)
# - Shock 1 (distribution): eta = log(xi) + eps_eta (eps_eta = 0.01 -> ~1% xi shock)
# - Shock 2 (employment): e + eps_e_abs (large, e.g., 0.05 = +5pp), clipped to <1
# - Plots both IRFs and "per 1%" normalized responses

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

out_dir <- here::here("outputs", "exploitation_rate", "phase_dependency")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters (Cambridge saving + depreciation)
# -----------------------------
alpha <- 0.02
beta  <- 0.01
gamma <- 0.01
delta <- 0.04
s_pi  <- 0.80

e_star_target     <- 0.95
omega_star_target <- 0.60

rho   <- (alpha + gamma) / e_star_target
sigma <- s_pi * (1 - omega_star_target) / (alpha + beta + delta)

A <- s_pi / sigma
B <- alpha + gamma
C <- alpha + beta + delta

q <- C / A
stopifnot(q > 0 && q < 1)

e_star  <- B / rho
xi_star <- q / (1 - q)
omega_star <- 1 / (1 + xi_star)

cat("Fixed point:\n")
cat("e*     =", e_star, "\n")
cat("omega* =", omega_star, "\n")
cat("xi*    =", xi_star, "\n\n")

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# -----------------------------
# 2) ODE model in (e, xi)
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

# -----------------------------
# 3) Option A admissibility via invariant H
# -----------------------------
H <- function(e, xi) {
  B*log(e) - rho*e - (A-C)*log(1+xi) - A/(1+xi)
}

e_turning_points <- function(H0, eps = 1e-10) {
  K <- H0 + (A - C) * log(1 + xi_star) + A / (1 + xi_star)
  F <- function(e) B * log(e) - rho * e - K
  
  e_hat <- min(max(B / rho, eps), 1 - eps)
  F_hat <- F(e_hat)
  if (!is.finite(F_hat) || F_hat <= 0) return(NULL)
  
  rL <- try(uniroot(F, c(eps, e_hat - eps))$root, silent = TRUE)
  rR <- try(uniroot(F, c(e_hat + eps, 1 - eps))$root, silent = TRUE)
  if (inherits(rL, "try-error") || inherits(rR, "try-error")) return(NULL)
  
  sort(c(rL, rR))
}

admissible_ic <- function(e0, omega0) {
  if (!is.finite(e0) || !is.finite(omega0)) return(FALSE)
  if (e0 <= 0 || e0 >= 1) return(FALSE)
  if (omega0 <= 0 || omega0 >= 1) return(FALSE)
  
  xi0 <- (1 - omega0) / omega0
  if (!is.finite(xi0) || xi0 <= 0) return(FALSE)
  
  H0 <- H(e0, xi0)
  roots <- e_turning_points(H0)
  if (is.null(roots) || length(roots) != 2) return(FALSE)
  
  list(ok = (roots[1] > 0 && roots[2] < 1), e_min=roots[1], e_max=roots[2], xi0=xi0, H0=H0)
}

shrink_kick_to_admissible <- function(e0_raw, omega0_raw, tol = 1e-6) {
  de <- e0_raw - e_star
  dw <- omega0_raw - omega_star
  test <- function(k) admissible_ic(e_star + k*de, omega_star + k*dw)
  
  r1 <- test(1)
  if (!isFALSE(r1) && r1$ok) {
    return(c(k=1, e0=e_star+de, omega0=omega_star+dw, e_min=r1$e_min, e_max=r1$e_max))
  }
  
  lo <- 0; hi <- 1
  best_k <- NA_real_; best_r <- NULL
  for (iter in 1:70) {
    mid <- 0.5*(lo+hi)
    rm <- test(mid)
    if (!isFALSE(rm) && rm$ok) { best_k <- mid; best_r <- rm; lo <- mid } else { hi <- mid }
    if (hi - lo < tol) break
  }
  if (is.na(best_k)) stop("No admissible non-degenerate orbit for this kick direction. Change raw IC.")
  c(k=best_k, e0=e_star+best_k*de, omega0=omega_star+best_k*dw, e_min=best_r$e_min, e_max=best_r$e_max)
}

# -----------------------------
# 4) Bigger orbit: more aggressive raw kick (Option A will shrink if needed)
# -----------------------------
# You asked for bigger amplitude. These are intentionally aggressive.
e0_raw     <- 0.80
omega0_raw <- 0.45

res <- shrink_kick_to_admissible(e0_raw, omega0_raw)
print(res)
cat("Invariant-implied e-range: [", res["e_min"], ",", res["e_max"], "]\n\n")

e0     <- unname(res["e0"])
omega0 <- unname(res["omega0"])
xi0    <- (1 - omega0) / omega0

# -----------------------------
# 5) Simulate baseline long enough to get clean Poincare cycle
# -----------------------------
dt <- 0.01
Tsim <- 600
times <- seq(0, Tsim, by = dt)

base <- ode(y = c(e=e0, xi=xi0), times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
base <- as.data.frame(base)
base$omega <- 1/(1+base$xi)
base$eta   <- log(base$xi)

cat("Baseline simulated ranges:\n")
cat("e    in [", min(base$e), ",", max(base$e), "]\n")
cat("omega in [", min(base$omega), ",", max(base$omega), "]\n")
cat("xi   in [", min(base$xi), ",", max(base$xi), "]\n\n")

# -----------------------------
# 6) Poincare section: upward crossings of e = e*
# -----------------------------
e_series <- base$e
t_series <- base$time

idx <- which(e_series[-length(e_series)] < e_star & e_series[-1] >= e_star)
if (length(idx) < 4) stop("Not enough Poincare crossings. Increase Tsim or change IC direction/amplitude.")

crossings <- data.frame(t=NA_real_, xi=NA_real_)
for (k in seq_along(idx)) {
  i <- idx[k]
  t1 <- t_series[i]; t2 <- t_series[i+1]
  e1 <- e_series[i]; e2 <- e_series[i+1]
  w  <- (e_star - e1) / (e2 - e1)
  tc <- t1 + w*(t2 - t1)
  
  xi1 <- base$xi[i]; xi2 <- base$xi[i+1]
  xic <- xi1 + w*(xi2 - xi1)
  
  crossings[k,] <- c(tc, xic)
}

# take last full cycle
t0 <- crossings$t[nrow(crossings)-2]
t1 <- crossings$t[nrow(crossings)-1]
Tper <- t1 - t0
cat("Estimated period:", Tper, "\n\n")

# -----------------------------
# 7) Phase grid on that cycle
# -----------------------------
n_phase <- 80
phase_grid <- seq(0, 2*pi, length.out = n_phase + 1)[-(n_phase+1)]
t_phase <- t0 + (phase_grid/(2*pi))*Tper

e_phase  <- approx(base$time, base$e,  xout = t_phase)$y
xi_phase <- approx(base$time, base$xi, xout = t_phase)$y

# -----------------------------
# 8) Two shocks (your spec)
# -----------------------------
eps_eta   <- 0.01   # 1% log-xi shock
eps_e_abs <- 0.05   # big employment shock: +5pp
e_cap     <- 0.999  # keep ODE admissible

Hmax <- 30
dt_h <- 0.01
t_h <- seq(0, Hmax, by = dt_h)
horizons <- c(0.5, 1, 2, 5, 10, 20, 30)

simulate_forward <- function(e_init, xi_init) {
  out <- ode(y = c(e=e_init, xi=xi_init), times = t_h, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
  out <- as.data.frame(out)
  out$omega <- 1/(1+out$xi)
  out
}

# -----------------------------
# 9) GIRFs by phase: store both shock types
# -----------------------------
girf <- expand.grid(phase = phase_grid, horizon = horizons)
girf$de_eta    <- NA_real_
girf$domega_eta<- NA_real_
girf$de_e      <- NA_real_
girf$domega_e  <- NA_real_

# normalized "per 1%" versions (divide by 0.01)
girf$de_eta_per1pct     <- NA_real_
girf$domega_eta_per1pct <- NA_real_

for (i in seq_along(phase_grid)) {
  e_init  <- e_phase[i]
  xi_init <- xi_phase[i]
  
  # baseline forward
  bwd <- simulate_forward(e_init, xi_init)
  
  # Shock A: eta shock (xi <- xi*exp(eps_eta))
  swd_eta <- simulate_forward(e_init, xi_init * exp(eps_eta))
  
  # Shock B: big e shock (e <- min(e+eps, e_cap))
  e_shocked <- min(e_init + eps_e_abs, e_cap)
  swd_e <- simulate_forward(e_shocked, xi_init)
  
  for (h in horizons) {
    eb <- approx(bwd$time, bwd$e, xout = h)$y
    wb <- approx(bwd$time, bwd$omega, xout = h)$y
    
    es_eta <- approx(swd_eta$time, swd_eta$e, xout = h)$y
    ws_eta <- approx(swd_eta$time, swd_eta$omega, xout = h)$y
    
    es_e <- approx(swd_e$time, swd_e$e, xout = h)$y
    ws_e <- approx(swd_e$time, swd_e$omega, xout = h)$y
    
    j <- which(girf$phase == phase_grid[i] & girf$horizon == h)
    
    girf$de_eta[j]     <- es_eta - eb
    girf$domega_eta[j] <- ws_eta - wb
    
    girf$de_e[j]       <- es_e - eb
    girf$domega_e[j]   <- ws_e - wb
    
    girf$de_eta_per1pct[j]     <- (es_eta - eb) / eps_eta
    girf$domega_eta_per1pct[j] <- (ws_eta - wb) / eps_eta
  }
}

csv_path <- file.path(out_dir, "phase_girf_two_shocks.csv")
write.csv(girf, csv_path, row.names = FALSE)
cat("Saved GIRF data to:\n", csv_path, "\n\n")

# -----------------------------
# 10) Plot helpers (clean ASCII labels, overlay both shocks)
# -----------------------------
plot_phase_overlay <- function(y_eta, y_e, h, ylab, main) {
  ord <- order(girf$phase[girf$horizon == h])
  ph  <- girf$phase[girf$horizon == h][ord]
  
  y1 <- y_eta[ord]
  y2 <- y_e[ord]
  
  plot(ph, y1, type="l",
       xlab="phase (radians, Poincare-timed)", ylab=ylab,
       main=paste0(main, " | horizon = ", h))
  lines(ph, y2, lty=2)
  abline(h=0, lty=3)
  legend("topright", legend=c("eta shock (1%)", "e shock (+5pp)"), lty=c(1,2), bty="n")
}

make_figure <- function(kind = c("de","domega","de_per1pct","domega_per1pct")) {
  kind <- match.arg(kind)
  
  op <- par(mfrow=c(2,2), mar=c(3,4,2,1))
  
  for (h in c(1, 5, 10, 30)) {
    sub <- girf[girf$horizon == h, ]
    ord <- order(sub$phase)
    
    if (kind == "de") {
      plot_phase_overlay(sub$de_eta, sub$de_e, h,
                         ylab="Delta e (shock - base)",
                         main="Phase GIRF: employment response")
    } else if (kind == "domega") {
      plot_phase_overlay(sub$domega_eta, sub$domega_e, h,
                         ylab="Delta omega (shock - base)",
                         main="Phase GIRF: wage-share response")
    } else if (kind == "de_per1pct") {
      # only eta shock has meaningful per-1% scaling here
      plot(sub$phase[ord], sub$de_eta_per1pct[ord], type="l",
           xlab="phase (radians, Poincare-timed)",
           ylab="(Delta e) per 1% eta shock",
           main=paste0("Phase elasticity-ish: e per 1% xi shock | horizon = ", h))
      abline(h=0, lty=3)
    } else if (kind == "domega_per1pct") {
      plot(sub$phase[ord], sub$domega_eta_per1pct[ord], type="l",
           xlab="phase (radians, Poincare-timed)",
           ylab="(Delta omega) per 1% eta shock",
           main=paste0("Phase elasticity-ish: omega per 1% xi shock | horizon = ", h))
      abline(h=0, lty=3)
    }
  }
  
  par(op)
}

# Save plots
png1 <- file.path(out_dir, "phase_overlay_de.png")
pdf1 <- file.path(out_dir, "phase_overlay_de.pdf")
png(png1, width=1600, height=1200, res=200); make_figure("de"); dev.off()
pdf(pdf1, width=10, height=8); make_figure("de"); dev.off()

png2 <- file.path(out_dir, "phase_overlay_domega.png")
pdf2 <- file.path(out_dir, "phase_overlay_domega.pdf")
png(png2, width=1600, height=1200, res=200); make_figure("domega"); dev.off()
pdf(pdf2, width=10, height=8); make_figure("domega"); dev.off()

png3 <- file.path(out_dir, "phase_eta_per1pct_de.png")
pdf3 <- file.path(out_dir, "phase_eta_per1pct_de.pdf")
png(png3, width=1600, height=1200, res=200); make_figure("de_per1pct"); dev.off()
pdf(pdf3, width=10, height=8); make_figure("de_per1pct"); dev.off()

png4 <- file.path(out_dir, "phase_eta_per1pct_domega.png")
pdf4 <- file.path(out_dir, "phase_eta_per1pct_domega.pdf")
png(png4, width=1600, height=1200, res=200); make_figure("domega_per1pct"); dev.off()
pdf(pdf4, width=10, height=8); make_figure("domega_per1pct"); dev.off()

cat("Saved plots:\n")
cat(png1, "\n", pdf1, "\n", png2, "\n", pdf2, "\n", png3, "\n", pdf3, "\n", png4, "\n", pdf4, "\n")
