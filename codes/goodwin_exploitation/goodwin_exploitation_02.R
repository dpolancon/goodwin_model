# OPTION A (single script): Admissible Goodwin orbit selection using invariant H
# Cambridge saving out of profits + depreciation; NO model change.
# Ensures implied orbit stays within 0<e(t)<1 by shrinking initial-condition "kick".

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

out_dir <- here::here("outputs", "exploitation_rate")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters
# -----------------------------
alpha <- 0.02
beta  <- 0.01
gamma <- 0.01      # in dw/w = -gamma + rho*e (gamma>0 is drag)
delta <- 0.04
s_pi  <- 0.80

# Choose interior steady-state targets (plausible levels)
e_star_target     <- 0.95
omega_star_target <- 0.60

# Calibrate rho, sigma to hit (e*, omega*) in Cambridge+delta version
rho   <- (alpha + gamma) / e_star_target
sigma <- s_pi * (1 - omega_star_target) / (alpha + beta + delta)

# constants
A <- s_pi / sigma
B <- alpha + gamma
C <- alpha + beta + delta

# fixed point in (e, xi)
q <- C / A
stopifnot(q > 0 && q < 1)

e_star  <- B / rho
xi_star <- q / (1 - q)
omega_star <- 1 / (1 + xi_star)

cat("Implied fixed point:\n")
cat("e*     =", e_star, "\n")
cat("omega* =", omega_star, "\n")
cat("xi*    =", xi_star, "\n")

# -----------------------------
# 2) First integral H(e,xi)
# H(e,xi)=B ln e - rho e - (A-C) ln(1+xi) - A/(1+xi)
# -----------------------------
H <- function(e, xi) {
  B*log(e) - rho*e - (A-C)*log(1+xi) - A/(1+xi)
}

# -----------------------------
# 3) Robust turning points for e (where xi = xi*)
# Solve B ln e - rho e = K for e in (0,1)
# Using concavity: at most 2 roots, symmetric around e_hat=B/rho
# -----------------------------
e_turning_points <- function(H0, eps = 1e-10) {
  K <- H0 + (A - C) * log(1 + xi_star) + A / (1 + xi_star)
  F <- function(e) B * log(e) - rho * e - K
  
  e_hat <- B / rho
  e_hat <- min(max(e_hat, eps), 1 - eps)
  
  F_hat <- F(e_hat)
  if (!is.finite(F_hat)) return(NULL)
  if (F_hat <= 0) return(NULL)  # need two roots for a non-degenerate orbit
  
  rL <- try(uniroot(F, c(eps, e_hat - eps))$root, silent = TRUE)
  rR <- try(uniroot(F, c(e_hat + eps, 1 - eps))$root, silent = TRUE)
  if (inherits(rL, "try-error") || inherits(rR, "try-error")) return(NULL)
  
  sort(c(rL, rR))
}

# -----------------------------
# 4) Admissibility gate for initial conditions (e0, omega0)
# Uses H0 -> (e_min, e_max). Requires 0<e_min<e_max<1.
# -----------------------------
admissible_ic <- function(e0, omega0) {
  if (!is.finite(e0) || !is.finite(omega0)) return(FALSE)
  if (e0 <= 0 || e0 >= 1) return(FALSE)
  if (omega0 <= 0 || omega0 >= 1) return(FALSE)
  
  xi0 <- (1 - omega0) / omega0
  if (!is.finite(xi0) || xi0 <= 0) return(FALSE)
  
  H0 <- H(e0, xi0)
  roots <- e_turning_points(H0)
  if (is.null(roots) || length(roots) != 2) return(FALSE)
  
  e_min <- roots[1]
  e_max <- roots[2]
  
  list(ok = (e_min > 0 && e_max < 1),
       e_min = e_min, e_max = e_max,
       H0 = H0, xi0 = xi0)
}

# -----------------------------
# 5) Kick shrinker: scale deviation from fixed point until admissible
# Returns largest k in [0,1] such that orbit implied by (e0,omega0) stays in (0,1).
# -----------------------------
shrink_kick_to_admissible <- function(e0_raw, omega0_raw, tol = 1e-6) {
  de <- e0_raw - e_star
  dw <- omega0_raw - omega_star
  
  test <- function(k) {
    e0 <- e_star + k*de
    w0 <- omega_star + k*dw
    admissible_ic(e0, w0)
  }
  
  r1 <- test(1)
  if (!isFALSE(r1) && r1$ok) {
    return(c(k=1, e0=e_star+de, omega0=omega_star+dw, e_min=r1$e_min, e_max=r1$e_max))
  }
  
  # k=0 is fixed point: admissible but degenerate (no cycle). Might fail "two roots" test.
  # So we treat k=0 as fallback only.
  lo <- 0
  hi <- 1
  best_k <- NA_real_
  best_r <- NULL
  
  for (iter in 1:70) {
    mid <- 0.5*(lo+hi)
    rm <- test(mid)
    
    if (!isFALSE(rm) && rm$ok) {
      best_k <- mid
      best_r <- rm
      lo <- mid
    } else {
      hi <- mid
    }
    if (hi - lo < tol) break
  }
  
  if (is.na(best_k)) {
    stop("No admissible (non-degenerate) orbit found for this direction of kick. Try a different raw IC.")
  }
  
  e_best <- e_star + best_k*de
  w_best <- omega_star + best_k*dw
  c(k=best_k, e0=e_best, omega0=w_best, e_min=best_r$e_min, e_max=best_r$e_max)
}

# -----------------------------
# 6) Model ODE in (e, xi) for optional verification sim
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# -----------------------------
# 7) Choose a raw kick and get an admissible IC
# -----------------------------
e0_raw     <- 0.92
omega0_raw <- 0.56

res <- shrink_kick_to_admissible(e0_raw, omega0_raw)
print(res)
cat("Implied orbit e-range (from invariant): [", res["e_min"], ",", res["e_max"], "]\n")

e0     <- unname(res["e0"])
omega0 <- unname(res["omega0"])
xi0    <- (1 - omega0) / omega0

# -----------------------------
# 8) OPTIONAL: simulate to confirm and save quick plots
# -----------------------------
times <- seq(0, 400, by = 0.1)
out <- ode(y = c(e=e0, xi=xi0), times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
out <- as.data.frame(out)
out$omega <- 1/(1+out$xi)

cat("\nSimulated ranges:\n")
cat("e    in [", min(out$e), ",", max(out$e), "]\n")
cat("omega in [", min(out$omega), ",", max(out$omega), "]\n")

png_path <- file.path(out_dir, "optionA_admissible_orbit_timeseries.png")
pdf_path <- file.path(out_dir, "optionA_admissible_orbit_timeseries.pdf")

make_plots <- function() {
  op <- par(mfrow=c(2,1), mar=c(3,4,2,1))
  plot(out$time, out$e, type="l", xlab="", ylab="e", main="Admissible orbit (simulation check)")
  abline(h=c(0,1), lty=3)
  plot(out$time, out$omega, type="l", xlab="time", ylab="omega")
  abline(h=c(0,1), lty=3)
  par(op)
}

png(png_path, width=1600, height=900, res=200); make_plots(); dev.off()
pdf(pdf_path, width=10, height=6); make_plots(); dev.off()

cat("\nSaved plots to:\n", png_path, "\n", pdf_path, "\n")
