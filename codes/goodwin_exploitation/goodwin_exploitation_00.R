# STEP 4C: Phase-dependent GIRFs (Poincare phase), ALL SHOCKS = 1%
# Model: Goodwin Cambridge + depreciation in (e, xi)
# Option A: enforce 0<e(t)<1 by admissible ICs via invariant H (no model change)
#
# Shocks (all 1%):
#   1) xi shock:    xi <- xi*(1+0.01)
#   2) omega shock: omega <- omega*(1+0.01), translated to xi' = 1/omega' - 1
#   3) e shock:     e <- e*(1+0.01), clipped below 1
#
# Outputs:
#   - Phase GIRFs: Delta e, Delta omega
#   - Elasticity-style: (Delta e / e0) per 1% shock, (Delta omega / omega0) per 1% shock
# Saved to: outputs/exploitation_rate/phase_dependency_1pct/

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

out_dir <- here::here("outputs", "exploitation_rate", "phase_dependency_1pct")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters (Cambridge saving + depreciation)
# -----------------------------
alpha <- 0.03
beta  <- 0.02
gamma <- 0.15
delta <- 0.04
s_pi  <- 0.80

# target fixed point (for interpretability)
e_star_target     <- 0.95
omega_star_target <- 0.45

rho   <- (alpha + gamma) / e_star_target
sigma <- s_pi * (1 - omega_star_target) / (alpha + beta + delta)

A <- s_pi / sigma
B <- alpha + gamma
C <- alpha + beta + delta

q <- C / A
stopifnot(q > 0 && q < 1)

e_star  <- B / rho
xi_star <- q / (1 - q)
omega_star <- 1 / (1 + xi_star)

cat("Fixed point:\n")
cat("e*     =", e_star, "\n")
cat("omega* =", omega_star, "\n")
cat("xi*    =", xi_star, "\n\n")

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# -----------------------------
# 2) ODE model in (e, xi)
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

# -----------------------------
# 3) Option A admissibility via invariant H
# -----------------------------
H <- function(e, xi) {
  B*log(e) - rho*e - (A-C)*log(1+xi) - A/(1+xi)
}

e_turning_points <- function(H0, eps = 1e-10) {
  K <- H0 + (A - C) * log(1 + xi_star) + A / (1 + xi_star)
  F <- function(e) B * log(e) - rho * e - K
  
  e_hat <- min(max(B / rho, eps), 1 - eps)
  F_hat <- F(e_hat)
  if (!is.finite(F_hat) || F_hat <= 0) return(NULL)
  
  rL <- try(uniroot(F, c(eps, e_hat - eps))$root, silent = TRUE)
  rR <- try(uniroot(F, c(e_hat + eps, 1 - eps))$root, silent = TRUE)
  if (inherits(rL, "try-error") || inherits(rR, "try-error")) return(NULL)
  
  sort(c(rL, rR))
}

admissible_ic <- function(e0, omega0) {
  if (!is.finite(e0) || !is.finite(omega0)) return(FALSE)
  if (e0 <= 0 || e0 >= 1) return(FALSE)
  if (omega0 <= 0 || omega0 >= 1) return(FALSE)
  
  xi0 <- (1 - omega0) / omega0
  if (!is.finite(xi0) || xi0 <= 0) return(FALSE)
  
  H0 <- H(e0, xi0)
  roots <- e_turning_points(H0)
  if (is.null(roots) || length(roots) != 2) return(FALSE)
  
  list(ok = (roots[1] > 0 && roots[2] < 1), e_min=roots[1], e_max=roots[2], xi0=xi0)
}

shrink_kick_to_admissible <- function(e0_raw, omega0_raw, tol = 1e-6) {
  de <- e0_raw - e_star
  dw <- omega0_raw - omega_star
  test <- function(k) admissible_ic(e_star + k*de, omega_star + k*dw)
  
  r1 <- test(1)
  if (!isFALSE(r1) && r1$ok) {
    return(c(k=1, e0=e_star+de, omega0=omega_star+dw, e_min=r1$e_min, e_max=r1$e_max))
  }
  
  lo <- 0; hi <- 1
  best_k <- NA_real_; best_r <- NULL
  for (iter in 1:70) {
    mid <- 0.5*(lo+hi)
    rm <- test(mid)
    if (!isFALSE(rm) && rm$ok) { best_k <- mid; best_r <- rm; lo <- mid } else { hi <- mid }
    if (hi - lo < tol) break
  }
  if (is.na(best_k)) stop("No admissible non-degenerate orbit for this kick direction. Change raw IC.")
  c(k=best_k, e0=e_star+best_k*de, omega0=omega_star+best_k*dw, e_min=best_r$e_min, e_max=best_r$e_max)
}

# -----------------------------
# 4) Bigger orbit: aggressive raw kick (shrinker keeps it admissible)
# -----------------------------
e0_raw     <- 0.78
omega0_raw <- 0.42

res <- shrink_kick_to_admissible(e0_raw, omega0_raw)
print(res)
cat("Invariant-implied e-range: [", res["e_min"], ",", res["e_max"], "]\n\n")

e0     <- unname(res["e0"])
omega0 <- unname(res["omega0"])
xi0    <- (1 - omega0) / omega0

# -----------------------------
# 5) Baseline simulation to define phase (Poincare section e=e*, upward)
# -----------------------------
dt <- 0.01
Tsim <- 700
times <- seq(0, Tsim, by = dt)

base <- ode(y = c(e=e0, xi=xi0), times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
base <- as.data.frame(base)
base$omega <- 1/(1+base$xi)

cat("Baseline simulated ranges:\n")
cat("e    in [", min(base$e), ",", max(base$e), "]\n")
cat("omega in [", min(base$omega), ",", max(base$omega), "]\n")
cat("xi   in [", min(base$xi), ",", max(base$xi), "]\n\n")

# upward crossings of e=e*
idx <- which(base$e[-nrow(base)] < e_star & base$e[-1] >= e_star)
if (length(idx) < 4) stop("Not enough Poincare crossings. Increase Tsim or change IC direction/amplitude.")

crossings <- data.frame(t=NA_real_, xi=NA_real_)
for (k in seq_along(idx)) {
  i <- idx[k]
  t1 <- base$time[i]; t2 <- base$time[i+1]
  e1 <- base$e[i];    e2 <- base$e[i+1]
  w  <- (e_star - e1) / (e2 - e1)
  tc <- t1 + w*(t2 - t1)
  
  xi1 <- base$xi[i]; xi2 <- base$xi[i+1]
  xic <- xi1 + w*(xi2 - xi1)
  
  crossings[k,] <- c(tc, xic)
}

# last full cycle
t0 <- crossings$t[nrow(crossings)-2]
t1 <- crossings$t[nrow(crossings)-1]
Tper <- t1 - t0
cat("Estimated period:", Tper, "\n\n")

# phase grid
n_phase <- 90
phase_grid <- seq(0, 2*pi, length.out = n_phase + 1)[-(n_phase+1)]
t_phase <- t0 + (phase_grid/(2*pi))*Tper

e_phase  <- approx(base$time, base$e,  xout = t_phase)$y
xi_phase <- approx(base$time, base$xi, xout = t_phase)$y
omega_phase <- 1/(1+xi_phase)

# -----------------------------
# 6) Shocks: ALL are 1% (multiplicative)
# -----------------------------
shock_pct <- 0.01
e_cap <- 0.999999  # avoid touching 1 exactly

# shock constructors (map phase state -> shocked initial state)
shock_xi <- function(e, xi) {
  list(e = e, xi = xi*(1+shock_pct))
}

shock_omega <- function(e, xi) {
  omega <- 1/(1+xi)
  omega_sh <- omega*(1+shock_pct)
  # keep omega in (0,1)
  omega_sh <- min(max(omega_sh, 1e-9), 1-1e-9)
  xi_sh <- 1/omega_sh - 1
  list(e = e, xi = xi_sh)
}

shock_e <- function(e, xi) {
  e_sh <- min(e*(1+shock_pct), e_cap)
  list(e = e_sh, xi = xi)
}

# -----------------------------
# 7) GIRF engine
# -----------------------------
Hmax <- 30
dt_h <- 0.01
t_h <- seq(0, Hmax, by = dt_h)
horizons <- c(0, 0.5, 1, 2, 5, 10, 20, 30)

simulate_forward <- function(e_init, xi_init) {
  out <- ode(y = c(e=e_init, xi=xi_init), times = t_h, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
  out <- as.data.frame(out)
  out$omega <- 1/(1+out$xi)
  out
}

# storage
make_storage <- function() {
  g <- expand.grid(phase = phase_grid, horizon = horizons)
  g$de <- NA_real_
  g$domega <- NA_real_
  g$elast_e <- NA_real_      # (Delta e / e0) / shock_pct
  g$elast_omega <- NA_real_  # (Delta omega / omega0) / shock_pct
  g
}

girf_xi    <- make_storage()
girf_omega <- make_storage()
girf_e     <- make_storage()

compute_girf <- function(shock_fun, label = "") {
  g <- make_storage()
  
  for (i in seq_along(phase_grid)) {
    e_init  <- e_phase[i]
    xi_init <- xi_phase[i]
    omega0  <- 1/(1+xi_init)
    
    # baseline
    bwd <- simulate_forward(e_init, xi_init)
    
    # shocked
    st <- shock_fun(e_init, xi_init)
    swd <- simulate_forward(st$e, st$xi)
    
    for (h in horizons) {
      eb <- approx(bwd$time, bwd$e, xout = h)$y
      wb <- approx(bwd$time, bwd$omega, xout = h)$y
      
      es <- approx(swd$time, swd$e, xout = h)$y
      ws <- approx(swd$time, swd$omega, xout = h)$y
      
      j <- which(g$phase == phase_grid[i] & g$horizon == h)
      de <- es - eb
      dw <- ws - wb
      
      g$de[j] <- de
      g$domega[j] <- dw
      
      # elasticity-style: percent response per 1% shock
      g$elast_e[j]     <- (de / e_init) / shock_pct
      g$elast_omega[j] <- (dw / omega0) / shock_pct
    }
  }
  
  g
}

cat("Computing GIRFs: xi shock (1%)...\n")
girf_xi <- compute_girf(shock_xi, "xi")
cat("Computing GIRFs: omega shock (1%) via xi mapping...\n")
girf_omega <- compute_girf(shock_omega, "omega")
cat("Computing GIRFs: e shock (1%)...\n")
girf_e <- compute_girf(shock_e, "e")

# save data
write.csv(girf_xi,    file.path(out_dir, "girf_phase_xi_1pct.csv"), row.names=FALSE)
write.csv(girf_omega, file.path(out_dir, "girf_phase_omega_1pct.csv"), row.names=FALSE)
write.csv(girf_e,     file.path(out_dir, "girf_phase_e_1pct.csv"), row.names=FALSE)

# -----------------------------
# 8) Plot overlays (3 shocks) for selected horizons
# -----------------------------
plot_overlay <- function(h, ykey, ylab, main) {
  sub_xi <- girf_xi[girf_xi$horizon == h, ]
  sub_om <- girf_omega[girf_omega$horizon == h, ]
  sub_e  <- girf_e[girf_e$horizon == h, ]
  
  sub_xi <- sub_xi[order(sub_xi$phase), ]
  sub_om <- sub_om[order(sub_om$phase), ]
  sub_e  <- sub_e[order(sub_e$phase), ]
  
  ord <- order(sub_xi$phase)
  ph <- sub_xi$phase[ord]
  
  sub_xi <- girf_xi[girf_xi$horizon == h, ]
  sub_om <- girf_omega[girf_omega$horizon == h, ]
  sub_e  <- girf_e[girf_e$horizon == h, ]
  
  sub_xi <- sub_xi[order(sub_xi$phase), ]
  sub_om <- sub_om[order(sub_om$phase), ]
  sub_e  <- sub_e[order(sub_e$phase), ]
  
  plot(sub_xi$phase, sub_xi[[ykey]], type="l",
       xlab="phase (radians, Poincare-timed)", ylab=ylab,
       main=paste0(main, " | horizon = ", h))
  
  lines(sub_om$phase, sub_om[[ykey]], lty=2)
  lines(sub_e$phase,  sub_e[[ykey]],  lty=3)
  
  abline(h=0, lty=3)
  legend("topright",
         legend=c("xi shock (1%)", "omega shock (1%)", "e shock (1%)"),
         lty=c(1,2,3), bty="n")
}

make_panel <- function(ykey, ylab, main, file_stub) {
  png_path <- file.path(out_dir, paste0(file_stub, ".png"))
  pdf_path <- file.path(out_dir, paste0(file_stub, ".pdf"))
  
  png(png_path, width=1600, height=1200, res=200)
  op <- par(mfrow=c(2,2), mar=c(3,4,2,1))
  for (h in c(1, 5, 10, 30)) plot_overlay(h, ykey, ylab, main)
  par(op)
  dev.off()
  
  pdf(pdf_path, width=10, height=8)
  op <- par(mfrow=c(2,2), mar=c(3,4,2,1))
  for (h in c(1, 5, 10, 30)) plot_overlay(h, ykey, ylab, main)
  par(op)
  dev.off()
  
  cat("Saved:\n", png_path, "\n", pdf_path, "\n\n")
}

# Level GIRFs
make_panel("de",     "Delta e (shock - base)",      "Phase GIRF: employment", "phase_overlay_DE_levels")
make_panel("domega", "Delta omega (shock - base)",  "Phase GIRF: wage share", "phase_overlay_DOMEGA_levels")

# Elasticity-style (percent response per 1% shock)
make_panel("elast_e",     "Elasticity of e (per 1% shock)",     "Phase elasticity: e", "phase_overlay_DE_elasticity")
make_panel("elast_omega", "Elasticity of omega (per 1% shock)", "Phase elasticity: omega", "phase_overlay_DOMEGA_elasticity")

cat("Done. Outputs in:\n", out_dir, "\n")
