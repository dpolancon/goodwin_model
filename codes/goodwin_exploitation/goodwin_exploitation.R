# STEP 2: State-dependence atlas in (e, xi)
# - Cambridge saving out of profits + depreciation
# - Nullclines + trace=0 + det=0 contours + simulated orbit
# - Along-orbit: trJ(t), detJ(t), cross-derivatives
# Saves to outputs/exploitation_rate/

if (!requireNamespace("deSolve", quietly = TRUE)) install.packages("deSolve")
if (!requireNamespace("here", quietly = TRUE))   install.packages("here")
library(deSolve)
library(here)

out_dir <- here::here("outputs", "exploitation_rate")
dir.create(out_dir, recursive = TRUE, showWarnings = FALSE)

# -----------------------------
# 1) Parameters (choose plausible center, not a hard band)
# -----------------------------
alpha <- 0.02
beta  <- 0.01
gamma <- 0.01      # in dw/w = -gamma + rho*e  (so gamma>0 is "drag")
delta <- 0.04      # depreciation
s_pi  <- 0.80      # saving rate out of profits

# Target steady state location (adjust to taste)
e_star     <- 0.95
omega_star <- 0.60

# Calibrate rho and sigma to hit (e*, omega*) in this Cambridge+delta version
rho   <- (alpha + gamma) / e_star
sigma <- s_pi * (1 - omega_star) / (alpha + beta + delta)

parms <- list(alpha=alpha, beta=beta, gamma=gamma, delta=delta,
              s_pi=s_pi, rho=rho, sigma=sigma)

# Convenient constants
A <- parms$s_pi / parms$sigma
B <- parms$alpha + parms$gamma
C <- parms$alpha + parms$beta + parms$delta

# Fixed point in (e, xi)
e_fp  <- B / parms$rho
q     <- C / A
xi_fp <- q / (1 - q)

cat("Implied fixed point:\n")
cat("e*     =", e_fp, "\n")
cat("omega* =", 1/(1+xi_fp), "\n")
cat("xi*    =", xi_fp, "\n")

stopifnot(q > 0 && q < 1)  # interior admissibility

# -----------------------------
# 2) Model in (e, xi)
# -----------------------------
goodwin_cambridge_e_xi <- function(t, state, p) {
  e  <- state[["e"]]
  xi <- state[["xi"]]
  
  A <- p$s_pi / p$sigma
  B <- p$alpha + p$gamma
  C <- p$alpha + p$beta + p$delta
  
  de  <- e  * (A * (xi/(1+xi)) - C)
  dxi <- (1 + xi) * (B - p$rho * e)
  
  list(c(de, dxi))
}

# -----------------------------
# 3) Choose initial conditions (IMPORTANT: not exactly at the fixed point)
# -----------------------------
e0     <- 0.92
omega0 <- 0.56
xi0    <- (1 - omega0) / omega0

state0 <- c(e = e0, xi = xi0)

# -----------------------------
# 4) Simulate orbit
# -----------------------------
times <- seq(0, 400, by = 0.1)
out <- ode(y = state0, times = times, func = goodwin_cambridge_e_xi, parms = parms, method = "lsoda")
out <- as.data.frame(out)

# Derived variables
out$omega <- 1 / (1 + out$xi)
out$eta   <- log(out$xi)

# -----------------------------
# 5) Jacobian fields: trace, det, and key cross-derivatives along the orbit
# -----------------------------
# J(e,xi) =
# [ A*xi/(1+xi)-C           e*A/(1+xi)^2 ]
# [ -rho*(1+xi)             B - rho*e    ]

out$trJ <- (A * out$xi/(1+out$xi) - C) + (B - parms$rho * out$e)
out$detJ <- (A * out$xi/(1+out$xi) - C) * (B - parms$rho * out$e) + (parms$rho * out$e * A)/(1 + out$xi)

out$dedxi <- out$e * A / (1 + out$xi)^2
out$dxide <- -parms$rho * (1 + out$xi)

# Quick orbit summary
tail <- out[out$time > max(out$time)*0.5, ]
cat("\nSecond-half ranges (for sanity):\n")
cat("e    in [", min(tail$e), ", ", max(tail$e), "]\n")
cat("omega in [", min(tail$omega), ", ", max(tail$omega), "]\n")
cat("xi   in [", min(tail$xi), ", ", max(tail$xi), "]\n")

# -----------------------------
# 6) Build phase-plane grid for tr=0 and det=0 contours
# -----------------------------
e_grid  <- seq(max(0.01, min(tail$e)*0.8), min(1.2, max(tail$e)*1.2), length.out = 160)
xi_grid <- seq(max(0.001, min(tail$xi)*0.5), max(tail$xi)*1.5, length.out = 160)

TR  <- matrix(NA_real_, nrow=length(e_grid), ncol=length(xi_grid))
DET <- matrix(NA_real_, nrow=length(e_grid), ncol=length(xi_grid))

for (i in seq_along(e_grid)) {
  e_val <- e_grid[i]
  for (j in seq_along(xi_grid)) {
    xi_val <- xi_grid[j]
    tr <- (A*xi_val/(1+xi_val) - C) + (B - parms$rho*e_val)
    det <- (A*xi_val/(1+xi_val) - C) * (B - parms$rho*e_val) + (parms$rho*e_val*A)/(1+xi_val)
    TR[i,j]  <- tr
    DET[i,j] <- det
  }
}

# Nullclines
# e-nullcline: xi = xi_fp (vertical)
# xi-nullcline: e = e_fp (horizontal)

# -----------------------------
# 7) Save plots
# -----------------------------
png_path <- file.path(out_dir, "step2_atlas_xi.png")
pdf_path <- file.path(out_dir, "step2_atlas_xi.pdf")

make_plots <- function() {
  op <- par(mfrow=c(3,1), mar=c(3,4,2,1))
  
  # (1) Phase plane atlas
  plot(NA, xlim=range(xi_grid), ylim=range(e_grid),
       xlab="xi (exploitation rate)", ylab="e (employment rate)",
       main="Phase plane: nullclines + trJ=0 + detJ=0 + orbit")
  
  # contours
  contour(xi_grid, e_grid, t(TR), levels=0, add=TRUE, lty=2, drawlabels=FALSE)
  contour(xi_grid, e_grid, t(DET), levels=0, add=TRUE, lty=3, drawlabels=FALSE)
  
  # nullclines
  abline(h = e_fp, lty=2)
  abline(v = xi_fp, lty=2)
  
  # orbit
  lines(out$xi, out$e)
  
  legend("topright",
         legend=c("orbit", "nullclines", "trJ=0", "detJ=0"),
         lty=c(1,2,2,3), bty="n")
  
  # (2) Time series: e, omega, xi
  plot(out$time, out$e, type="l", xlab="", ylab="e", main="Time series")
  abline(h=e_fp, lty=2)
  
  plot(out$time, out$omega, type="l", xlab="", ylab="omega")
  abline(h=1/(1+xi_fp), lty=2)
  
  # (3) Along-orbit state dependence: trJ, detJ, and key cross-effects
  plot(out$time, out$trJ, type="l", xlab="time", ylab="trJ", main="Along-orbit diagnostics")
  abline(h=0, lty=2)
  
  par(op)
}

png(png_path, width=1600, height=1200, res=200); make_plots(); dev.off()
pdf(pdf_path, width=10, height=9); make_plots(); dev.off()

cat("\nSaved atlas plots to:\n", png_path, "\n", pdf_path, "\n")

# Optional: save the underlying time series for later mapping
csv_path <- file.path(out_dir, "step2_orbit_with_jacobian.csv")
write.csv(out, csv_path, row.names=FALSE)
cat("Saved orbit data to:\n", csv_path, "\n")
