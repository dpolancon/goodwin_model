## ============================================================
## 2) Enforce u_d = u_star at SS by calibrating varsigma0
##    Key: varsigma0 does NOT enter Delta (in your implementation),
##    so this calibration is not circular.
## ============================================================
calibrate_varsigma0_at_ss <- function(par, t0 = 0) {
require_params(par, c("u_star","varsigma1","varsigma0"))
if (abs(par$varsigma1) > 0) {
warning("varsigma1 != 0: calibration will only enforce u_d=u_star at t0, not over time.")
}
ss <- steady_state_reduced(par)
if (!isTRUE(ss$ok)) return(list(ok = FALSE, reason = ss$reason, par = par))
Delta_star <- Delta_fun_uStar(t0, ss$omega, ss$d, par)
if (!is.finite(Delta_star) || Delta_star <= 1e-10) {
return(list(ok = FALSE, reason = "Delta* nonpositive at SS; cannot calibrate varsigma0", par = par))
}
## enforce u_d = cbar/Delta = u_star at SS, with cbar(t0)=varsigma0*exp(varsigma1*t0)=varsigma0
par2 <- par
par2$varsigma0 <- par$u_star * Delta_star
list(ok = TRUE, par = par2, ss = ss, Delta_star = Delta_star)
}
## ============================================================
## 3) Reduced Jacobian (e, omega, d) at SS (unchanged structure)
## ============================================================
jacobian_reduced_at_ss <- function(ss, par) {
e <- ss$e; omega <- ss$omega; d <- ss$d
g_n <- ss$g_n
A <- ss$A
r <- ss$r
kap_r <- kappa_r_fun(r, par)
Phi_e <- Phi_e_fun(e, par)
J <- matrix(0, 3, 3)
## de depends on gY which depends on omega,d through kappa(r_net)
J[1,2] <- - e * (A^2) * kap_r
J[1,3] <- - e * (A^2) * par$i * kap_r
## domega depends on e
J[2,1] <- omega * Phi_e
## dd depends on omega,d via kappa and also on gY term
J[3,2] <- 1 - A * kap_r + d * (A^2) * kap_r
J[3,3] <- (par$i - g_n) - A * par$i * kap_r + d * (A^2) * par$i * kap_r
list(J = J, kappa_r = kap_r, Phi_e = Phi_e)
}
rh_hopf_reduced <- function(J) {
trJ  <- sum(diag(J))
M2 <- (J[1,1]*J[2,2] - J[1,2]*J[2,1]) +
(J[1,1]*J[3,3] - J[1,3]*J[3,1]) +
(J[2,2]*J[3,3] - J[2,3]*J[3,2])
detJ <- det(J)
a1 <- -trJ
a2 <- M2
a3 <- -detJ
H <- a1 * a2 - a3
feasible_RH <- (a1 > 0) && (a2 > 0) && (a3 > 0)
list(a1 = a1, a2 = a2, a3 = a3, H = H, feasible_RH = feasible_RH)
}
analyze_reduced <- function(par, calibrate_varsigma0 = TRUE) {
if (calibrate_varsigma0) {
cal <- calibrate_varsigma0_at_ss(par)
if (!isTRUE(cal$ok)) return(list(ok = FALSE, reason = cal$reason))
par <- cal$par
}
ss <- steady_state_reduced(par)
if (!isTRUE(ss$ok)) return(list(ok = FALSE, reason = ss$reason))
Jp <- jacobian_reduced_at_ss(ss, par)
rh <- rh_hopf_reduced(Jp$J)
eig <- eigen(Jp$J)$values
list(
ok = TRUE,
par = par,
steady_state = ss,
jacobian = Jp$J,
eigenvalues = eig,
rh = rh,
jac_parts = list(kappa_r = Jp$kappa_r, Phi_e = Jp$Phi_e)
)
}
## ============================================================
## 4) Hopf mapping utilities on a 2D parameter plane
## ============================================================
grid_values <- function(lo, hi, n) seq(lo, hi, length.out = n)
hopf_plane <- function(par_base,
p1, p2,
p1_vals, p2_vals,
calibrate_varsigma0 = TRUE,
H_band = 1e-3) {
stopifnot(p1 %in% names(par_base), p2 %in% names(par_base))
res <- vector("list", length(p1_vals) * length(p2_vals))
k <- 0
for (v1 in p1_vals) {
for (v2 in p2_vals) {
k <- k + 1
par <- par_base
par[[p1]] <- v1
par[[p2]] <- v2
out <- analyze_reduced(par, calibrate_varsigma0 = calibrate_varsigma0)
if (!isTRUE(out$ok)) {
res[[k]] <- tibble(
!!p1 := v1, !!p2 := v2,
ok = FALSE,
reason = out$reason,
a1 = NA_real_, a2 = NA_real_, a3 = NA_real_, H = NA_real_,
feasible_RH = FALSE,
hopf_band = FALSE
)
} else {
rh <- out$rh
res[[k]] <- tibble(
!!p1 := v1, !!p2 := v2,
ok = TRUE,
reason = NA_character_,
a1 = rh$a1, a2 = rh$a2, a3 = rh$a3, H = rh$H,
feasible_RH = rh$feasible_RH,
hopf_band = isTRUE(rh$feasible_RH) && is.finite(rh$H) && (abs(rh$H) < H_band)
)
}
}
}
bind_rows(res)
}
score_hopf_plane <- function(df, H_band = 1e-3) {
df_ok <- df %>% filter(ok)
df_feas <- df_ok %>% filter(feasible_RH)
feasible_share <- nrow(df_feas) / max(1, nrow(df_ok))
hopf_band_share <- (df_feas %>% filter(abs(H) < H_band) %>% nrow()) / max(1, nrow(df_feas))
## Boundary existence proxy: sign change of H within feasible RH region
sgn <- sign(df_feas$H)
has_pos <- any(sgn > 0, na.rm = TRUE)
has_neg <- any(sgn < 0, na.rm = TRUE)
sign_change <- has_pos && has_neg
tibble(
n_ok = nrow(df_ok),
n_feasible = nrow(df_feas),
feasible_share = feasible_share,
hopf_band_share = hopf_band_share,
sign_change = sign_change
)
}
## ============================================================
## Plot hopf plane with sign(H) (paper-grade diagnostic)
## ============================================================
plot_hopf_plane_signH <- function(df, p1, p2, title = NULL) {
df2 <- df %>%
mutate(
status = case_when(
!ok ~ "SS infeasible",
ok & !feasible_RH ~ "RH prereq fail (a1/a2/a3)",
ok & feasible_RH & is.finite(H) & H > 0 ~ "H>0 (stable focus)",
ok & feasible_RH & is.finite(H) & H < 0 ~ "H<0 (unstable)",
ok & feasible_RH & is.finite(H) & abs(H) <= 1e-10 ~ "H≈0",
TRUE ~ "Other"
),
status = factor(status, levels = c(
"SS infeasible",
"RH prereq fail (a1/a2/a3)",
"H>0 (stable focus)",
"H<0 (unstable)",
"H≈0",
"Other"
))
)
ggplot(df2, aes(x = .data[[p1]], y = .data[[p2]])) +
geom_tile(aes(fill = status), alpha = 0.9) +
geom_contour(aes(z = H), breaks = 0, linewidth = 0.55, na.rm = TRUE) +
labs(
title = title %||% paste0("Hopf plane: ", p2, " vs ", p1),
subtitle = "Tiles: SS feasibility + RH prereqs + sign(H). Contour: H=0 (Hopf boundary candidate).",
x = p1, y = p2, fill = NULL
)
}
## ============================================================
## 5) Search over candidate parameter planes to “maximize Hopf space”
## ============================================================
compare_planes <- function(par_base, planes,
ranges, n = 80,
H_band = 1e-3,
calibrate_varsigma0 = TRUE) {
out <- vector("list", length(planes))
for (j in seq_along(planes)) {
p1 <- planes[[j]][1]
p2 <- planes[[j]][2]
p1_rng <- ranges[[p1]]
p2_rng <- ranges[[p2]]
stopifnot(length(p1_rng) == 2, length(p2_rng) == 2)
df <- hopf_plane(
par_base,
p1 = p1, p2 = p2,
p1_vals = grid_values(p1_rng[1], p1_rng[2], n),
p2_vals = grid_values(p2_rng[1], p2_rng[2], n),
calibrate_varsigma0 = calibrate_varsigma0,
H_band = H_band
)
sc <- score_hopf_plane(df, H_band = H_band) %>%
mutate(p1 = p1, p2 = p2)
out[[j]] <- sc
}
bind_rows(out) %>%
arrange(desc(sign_change), desc(hopf_band_share), desc(feasible_share))
}
## ============================================================
## 6) Full simulation with RESIDUAL u (no feedback into e,omega,d)
## ============================================================
rhs_full_residual_u <- function(t, state, par) {
e <- state[["e"]]
w <- state[["omega"]]
d <- state[["d"]]
u <- state[["u"]]
## guardrails (still)
e <- min(max(e, 1e-9), 1 - 1e-9)
w <- min(max(w, 1e-9), 1 - 1e-9)
d <- max(d, 1e-12)
u <- max(u, 1e-9)
## Core dynamics computed at u = u_star (residual follower)
r   <- r_net_reduced(w, d, par)
kap <- kappa_fun(r, par)
gK <- (par$u_star * kap) / par$sigma - par$delta
gY <- gK                      ## NO gU feedback into core
g_n <- par$alpha + par$beta
Phi <- Phi_fun(e, par)
de  <- (gY - g_n) * e
dw  <- (Phi - par$alpha) * w
dd  <- kap - (1 - w) + par$i * d - d * gY
## Residual follower utilization
u_d <- u_desired_uStar(t, w, d, par)
if (!is.finite(u_d)) {
du <- 0
gU <- 0
} else {
du <- par$lambda_u * (u_d - u)
gU <- du / u
}
## Diagnostics for inequality (uses realized u, not u_star)
rho  <- par$sigma / u
chiA <- par$p * rho + d
chiN <- -d
xi   <- chiA / abs(chiN)
Delta <- Delta_fun_uStar(t, w, d, par)
list(
c(de, dw, dd, du),
c(r = r, kappa = kap, gK = gK, gY = gY,
Delta = Delta, u_d = u_d, gU = gU,
rho = rho, chiA = chiA, chiN = chiN, xi = xi)
)
}
simulate_full_residual_u <- function(par, state0 = NULL,
t_end = 700, dt = 0.05,
perturb = c(e = 0.01, omega = -0.01, d = 0.05, u = -0.05),
calibrate_varsigma0 = TRUE) {
if (calibrate_varsigma0) {
cal <- calibrate_varsigma0_at_ss(par)
if (!isTRUE(cal$ok)) stop("Calibration failed: ", cal$reason)
par <- cal$par
ss  <- cal$ss
} else {
ss <- steady_state_reduced(par)
if (!isTRUE(ss$ok)) stop("No admissible reduced SS: ", ss$reason)
}
if (is.null(state0)) {
state0 <- c(
e = ss$e + perturb[["e"]],
omega = ss$omega + perturb[["omega"]],
d = ss$d + perturb[["d"]],
u = par$u_star + perturb[["u"]]
)
}
times <- seq(0, t_end, by = dt)
sol <- ode(
y = state0,
times = times,
func = rhs_full_residual_u,
parms = par,
method = "lsoda"
)
as.data.frame(sol) |> as_tibble()
}
## ============================================================
## Tail diagnostics (minimal table for deliverable)
## ============================================================
tail_window <- function(df, frac = 0.25) {
n <- nrow(df)
i0 <- max(1, floor((1 - frac) * n))
df[i0:n, , drop = FALSE]
}
amp <- function(x) {
x <- x[is.finite(x)]
if (length(x) < 20) return(NA_real_)
as.numeric(quantile(x, 0.95) - quantile(x, 0.05))
}
period_peaks <- function(t, x, min_prom = NULL) {
## crude peak-to-peak period proxy using local maxima
x <- as.numeric(x); t <- as.numeric(t)
ok <- is.finite(x) & is.finite(t)
x <- x[ok]; t <- t[ok]
if (length(x) < 200) return(NA_real_)
dx1 <- diff(x)
peaks <- which(dx1[-1] < 0 & dx1[-length(dx1)] > 0) + 1  # sign change + to -
if (length(peaks) < 3) return(NA_real_)
if (!is.null(min_prom)) {
keep <- x[peaks] > (median(x) + min_prom)
peaks <- peaks[keep]
if (length(peaks) < 3) return(NA_real_)
}
median(diff(t[peaks]))
}
summarize_tail <- function(df, name, frac_tail = 0.25) {
dft <- tail_window(df, frac_tail)
tibble(
run = name,
time_end = max(df$time, na.rm = TRUE),
e_mean = mean(dft$e, na.rm = TRUE),
e_sd   = sd(dft$e, na.rm = TRUE),
e_amp  = amp(dft$e),
omega_mean = mean(dft$omega, na.rm = TRUE),
omega_sd   = sd(dft$omega, na.rm = TRUE),
omega_amp  = amp(dft$omega),
d_mean = mean(dft$d, na.rm = TRUE),
d_sd   = sd(dft$d, na.rm = TRUE),
d_amp  = amp(dft$d),
u_mean = mean(dft$u, na.rm = TRUE),
u_sd   = sd(dft$u, na.rm = TRUE),
u_amp  = amp(dft$u),
xi_mean = mean(dft$xi, na.rm = TRUE),
xi_sd   = sd(dft$xi, na.rm = TRUE),
xi_amp  = amp(log(pmax(dft$xi, 1e-12))),
gY_mean = mean(dft$gY, na.rm = TRUE),
period_e = period_peaks(dft$time, dft$e)
)
}
## ============================================================
## Minimal plots for scenario sims
## ============================================================
plot_scenario_timeseries <- function(df, tag, out_dir = OUT_DIR) {
p <- df %>%
select(time, e, omega, d, u, xi) %>%
pivot_longer(-time, names_to = "var", values_to = "value") %>%
ggplot(aes(x = time, y = value)) +
geom_line() +
facet_wrap(~var, scales = "free_y", ncol = 1) +
labs(title = paste0("Scenario time paths (", tag, ")"), x = "t", y = NULL)
ggsave(fs::path(out_dir, paste0("scenario_timeseries_", tag, ".png")),
p, width = 7.2, height = 9.0, dpi = 160)
p
}
plot_scenario_phase <- function(df, tag, out_dir = OUT_DIR) {
p1 <- ggplot(df, aes(x = e, y = omega)) +
geom_path(alpha = 0.85) +
labs(title = paste0("Phase: omega vs e (", tag, ")"), x = "e", y = "omega")
ggsave(fs::path(out_dir, paste0("scenario_phase_omega_vs_e_", tag, ".png")),
p1, width = 6.6, height = 5.6, dpi = 160)
p2 <- ggplot(df, aes(x = d, y = xi)) +
geom_path(alpha = 0.85) +
labs(title = paste0("Phase: xi vs d (", tag, ")"), x = "d", y = "xi")
ggsave(fs::path(out_dir, paste0("scenario_phase_xi_vs_d_", tag, ".png")),
p2, width = 6.6, height = 5.6, dpi = 160)
invisible(list(p_omega_e = p1, p_xi_d = p2))
}
## ============================================================
## 7) DRIVER: minimal deliverables (Figure A, Figure B, scenario table)
## ============================================================
## -----------------------------
## Baseline calibration
## -----------------------------
par_base <- list(
## growth / tech
alpha = 0.02, beta = 0.01,
delta = 0.02,
sigma = 3.0,
u_star = 1.0,
## finance
i = 0.04,
## investment (logistic)
kappa_min = 0.00, kappa_max = 0.30,
lambda = 20,
r0 = 0.04,
## Phillips
phi0 = -0.06,
phi1 = 0.10,
## utilization adjustment speed (residual follower only)
lambda_u = 2.0,
## price (wealth accounting)
p = 1.0,
## autonomous consumption (will be calibrated)
varsigma0 = 0.55,
varsigma1 = 0.00,
## induced non-owner consumption
cN_minus = 0.02,
cN_plus  = 0.20,
cN_eta   = 0.10,
## owners saving
sA_const  = TRUE,
sA0       = 0.40,
sA_min    = 0.20, sA_max = 0.80, sA_lambda = 2.0, sA_mid = 2.0,
## optional leakage psi(d)
psi_zero  = TRUE,
psi_max   = 0.00, psi_lambda = 5.0, psi_mid = 1.0
)
## -----------------------------
## Candidate planes + ranges
## -----------------------------
planes <- list(
c("phi1","lambda"),
c("i","lambda"),
c("phi1","i"),
c("phi0","phi1"),
c("r0","lambda")
)
ranges <- list(
phi1   = c(0.03, 0.25),
lambda = c(5, 150),
i      = c(0.00, 0.10),
phi0   = c(-0.12, -0.01),
r0     = c(0.01, 0.08)
)
## ============================================================
## Deliverable 1: rank planes (export)
## ============================================================
scores <- compare_planes(
par_base,
planes = planes,
ranges = ranges,
n = 80,
H_band = 1e-3,
calibrate_varsigma0 = TRUE
)
write.csv(scores, fs::path(OUT_DIR, "hopf_plane_scores.csv"), row.names = FALSE)
print(scores)
## ============================================================
## Deliverable 2: Figure A (phi1, lambda) with sign(H) tiles
## ============================================================
df_A <- hopf_plane(
par_base,
p1 = "phi1", p2 = "lambda",
p1_vals = grid_values(ranges$phi1[1], ranges$phi1[2], 140),
p2_vals = grid_values(ranges$lambda[1], ranges$lambda[2], 140),
calibrate_varsigma0 = TRUE,
H_band = 1e-3
)
write.csv(df_A, fs::path(OUT_DIR, "hopf_plane_phi1_lambda.csv"), row.names = FALSE)
pA <- plot_hopf_plane_signH(df_A, "phi1", "lambda",
title = "FIG A: Hopf map (lambda vs phi1) with sign(H)")
ggsave(fs::path(OUT_DIR, "FIG_A_hopf_plane_signH_phi1_lambda.png"),
pA, width = 7.2, height = 6.0, dpi = 160)
## ============================================================
## Deliverable 3: Figure B (choose a richer/curvier plane)
## - default to top-ranked plane, but avoid duplicating (phi1,lambda)
## ============================================================
top <- scores %>% slice(1)
p1B <- top$p1
p2B <- top$p2
if (identical(c(p1B, p2B), c("phi1","lambda"))) {
## force a second plane with curvature
p1B <- "r0"; p2B <- "lambda"
}
df_B <- hopf_plane(
par_base,
p1 = p1B, p2 = p2B,
p1_vals = grid_values(ranges[[p1B]][1], ranges[[p1B]][2], 140),
p2_vals = grid_values(ranges[[p2B]][1], ranges[[p2B]][2], 140),
calibrate_varsigma0 = TRUE,
H_band = 1e-3
)
write.csv(df_B, fs::path(OUT_DIR, paste0("hopf_plane_", p1B, "_", p2B, ".csv")), row.names = FALSE)
pB <- plot_hopf_plane_signH(df_B, p1B, p2B,
title = paste0("FIG B: Hopf map (", p2B, " vs ", p1B, ") with sign(H)"))
ggsave(fs::path(OUT_DIR, paste0("FIG_B_hopf_plane_signH_", p1B, "_", p2B, ".png")),
pB, width = 7.2, height = 6.0, dpi = 160)
## ============================================================
## Deliverable 4: scenario sims (below / near / above Hopf) using lambda
## ============================================================
phi1_pick <- par_base$phi1
par_root <- par_base
par_root$phi1 <- phi1_pick
lambda_star <- find_hopf_mu(
par_root, mu = "lambda",
lo = ranges$lambda[1], hi = ranges$lambda[2],
n_grid = 350,
calibrate_varsigma0 = TRUE,
verbose = TRUE
)
cat(sprintf("\n[DRIVER] Hopf approx: lambda* = %.6f at phi1 = %.4f\n", lambda_star, phi1_pick))
lambda_vals <- c(
below = 0.70 * lambda_star,
near  = 0.98 * lambda_star,
above = 1.20 * lambda_star
)
lambda_vals <- pmin(pmax(lambda_vals, ranges$lambda[1]), ranges$lambda[2])
scenario_tbl <- list()
for (nm in names(lambda_vals)) {
par_s <- par_base
par_s$phi1 <- phi1_pick
par_s$lambda <- as.numeric(lambda_vals[[nm]])
tag <- paste0("phi1_", sprintf("%.3f", phi1_pick),
"_lambda_", nm, "_", sprintf("%.2f", par_s$lambda))
df_s <- simulate_full_residual_u(
par_s,
t_end = 700, dt = 0.05,
calibrate_varsigma0 = TRUE
)
## export sim
write.csv(df_s, fs::path(OUT_DIR, paste0("scenario_sim_", tag, ".csv")), row.names = FALSE)
## export plots
plot_scenario_timeseries(df_s, tag, out_dir = OUT_DIR)
plot_scenario_phase(df_s, tag, out_dir = OUT_DIR)
## tail summary row
scenario_tbl[[nm]] <- summarize_tail(df_s, name = tag, frac_tail = 0.25) %>%
mutate(phi1 = phi1_pick, lambda = par_s$lambda, lambda_star = lambda_star)
}
scenario_tbl <- bind_rows(scenario_tbl)
write.csv(scenario_tbl, fs::path(OUT_DIR, "TABLE_scenarios_tail_diagnostics.csv"), row.names = FALSE)
print(scenario_tbl)
############################################################
## End script
############################################################
