)
writeLines(tex_stage3, file.path(dir_stage3, "table_stage3_summary.tex"))
write_csv(tab_stage3, file.path(dir_stage3, "table_stage3_summary.csv"))
tab_hopf <- hopf_verified %>%
group_by(psi, kappa_max) %>%
summarise(
n_verified = n(),
rF_root_med = median(rF_root, na.rm=TRUE),
rF_root_p25 = quantile(rF_root, 0.25, na.rm=TRUE),
rF_root_p75 = quantile(rF_root, 0.75, na.rm=TRUE),
slope_med  = median(dmaxRe_drF, na.rm=TRUE),
.groups = "drop"
) %>%
arrange(psi, kappa_max)
tex_hopf <- df_to_latex_tabular(
tab_hopf,
caption = "Verified Hopf root summary by $(\\psi,\\kappa_{\\max})$ (median/quantiles).",
label   = "tab:hopf_summary",
align   = "rrrrrr"
)
writeLines(tex_hopf, file.path(dir_stage3, "table_hopf_summary.tex"))
write_csv(tab_hopf, file.path(dir_stage3, "table_hopf_summary.csv"))
# ------------------------------------------------------------
# Manifest: list every output under base_dir
# ------------------------------------------------------------
manifest <- tibble(
path = list.files(base_dir, recursive = TRUE, full.names = TRUE)
) %>%
mutate(
bytes = file.size(path),
ext   = tools::file_ext(path)
) %>%
arrange(path)
write_csv(manifest, file.path(base_dir, "manifest_outputs.csv"))
cat("\n====================\nOUTPUT MANIFEST (base_dir)\n====================\n")
print(manifest)
cat("\nSaved manifest to:\n  ", file.path(base_dir, "manifest_outputs.csv"), "\n", sep="")
cat("Saved Stage 3 LaTeX tables to:\n",
"  ", file.path(dir_stage3, "table_stage3_summary.tex"), "\n",
"  ", file.path(dir_stage3, "table_hopf_summary.tex"), "\n", sep="")
}
}
# ============================================================
# Stage 4 + Stage 5 (Consolidated)
# - Reads Stage 3 outputs: stage3_stability.csv, hopf_roots.csv
# - Stage 4: soft scoring + (optional) gating + shortlists + plots + LaTeX
# - Stage 5: builds sim plan around Hopf roots, runs ODE sims (USER HOOK),
#           computes simple cycle diagnostics, exports shortlist + plots + LaTeX
# ============================================================
suppressPackageStartupMessages({
library(dplyr)
library(tidyr)
library(readr)
library(ggplot2)
library(stringr)
library(tibble)
library(purrr)
})
cat("\n====================\nStage 4+5: start\n====================\n")
# ----------------------------
# Paths
# ----------------------------
base_dir   <- "outputs/wealth_goodwin/grid_search"
dir_stage3 <- file.path(base_dir, "stage3_stability")
dir_stage4 <- file.path(base_dir, "stage4_scoring")
dir_stage5 <- file.path(base_dir, "stage5_simulation")
dir.create(dir_stage4, showWarnings = FALSE, recursive = TRUE)
dir.create(dir_stage5, showWarnings = FALSE, recursive = TRUE)
stage3_file <- file.path(dir_stage3, "stage3_stability.csv")
hopf_file   <- file.path(dir_stage3, "hopf_roots.csv")
stopifnot(file.exists(stage3_file), file.exists(hopf_file))
# ----------------------------
# Helpers
# ----------------------------
to_bool <- function(x) {
if (is.logical(x)) return(ifelse(is.na(x), NA, x))
if (is.numeric(x)) return(ifelse(is.na(x), NA, x != 0))
if (is.character(x)) {
y <- tolower(trimws(x))
return(ifelse(y %in% c("true","t","1","yes","y"), TRUE,
ifelse(y %in% c("false","f","0","no","n"), FALSE, NA)))
}
rep(NA, length(x))
}
# Count peaks: simple local maxima count after smoothing-free rule
count_peaks <- function(y) {
y <- as.numeric(y)
if (length(y) < 5 || all(!is.finite(y))) return(NA_integer_)
y <- y[is.finite(y)]
if (length(y) < 5) return(NA_integer_)
dy <- diff(y)
s  <- sign(dy)
# peak when slope goes + to -
sum(s[-length(s)] > 0 & s[-1] < 0, na.rm = TRUE)
}
# Basic amplitude
amp <- function(y) {
y <- as.numeric(y)
if (all(!is.finite(y))) return(NA_real_)
y <- y[is.finite(y)]
if (length(y) == 0) return(NA_real_)
max(y) - min(y)
}
# Safe extraction of rF0 from hopf file (NO case_when; avoids "object rF not found")
add_rF0 <- function(hopf_df) {
hopf2 <- hopf_df
if ("rF0" %in% names(hopf2)) {
hopf2 <- hopf2 %>% mutate(rF0 = suppressWarnings(as.numeric(rF0)))
} else if ("rF" %in% names(hopf2)) {
hopf2 <- hopf2 %>% mutate(rF0 = suppressWarnings(as.numeric(rF)))
} else {
hopf2 <- hopf2 %>% mutate(rF0 = NA_real_)
}
hopf2
}
# ----------------------------
# Read Stage 3 inputs
# ----------------------------
stage3 <- readr::read_csv(stage3_file, show_col_types = FALSE)
hopf   <- readr::read_csv(hopf_file,   show_col_types = FALSE)
stage3_ok <- stage3 %>%
filter(reason == "ok") %>%
mutate(
RH_ok       = to_bool(RH_ok),
stable      = to_bool(stable),
has_complex = to_bool(has_complex)
) %>%
filter(is.finite(try_id), is.finite(cand_id), is.finite(rF)) %>%
filter(is.finite(omega_star), is.finite(sigma), is.finite(lambda_star))
hopf2 <- hopf %>%
mutate(
hopf_ok = to_bool(hopf_ok),
rF_root = suppressWarnings(as.numeric(rF_root))
) %>%
add_rF0()
hopf_verified <- hopf2 %>%
filter(is.finite(rF_root), is.finite(rF0)) %>%
filter((hopf_ok == TRUE) | (reason == "ok"))
# Aggregate hopf info per candidate (try_id,cand_id,rF0)
hopf_by_cand <- hopf_verified %>%
group_by(try_id, cand_id, rF0) %>%
summarise(
n_roots     = n(),
rF_root_med = median(rF_root, na.rm = TRUE),
rF_root_p25 = quantile(rF_root, 0.25, na.rm = TRUE),
rF_root_p75 = quantile(rF_root, 0.75, na.rm = TRUE),
maxIm_root_med = if ("maxIm_root" %in% names(.)) median(maxIm_root, na.rm = TRUE) else NA_real_,
.groups = "drop"
) %>%
mutate(
hopf_complex = is.finite(maxIm_root_med) & (maxIm_root_med > 1e-5)
)
df <- stage3_ok %>%
left_join(hopf_by_cand, by = c("try_id","cand_id", "rF" = "rF0")) %>%
mutate(
has_hopf = is.finite(rF_root_med) & (n_roots > 0)
)
cat("Input counts:\n")
cat("  stage3_ok rows     =", nrow(stage3_ok), "\n")
cat("  hopf_verified rows =", nrow(hopf_verified), "\n")
cat("  merged rows        =", nrow(df), "\n")
# ============================================================
# STAGE 4: Scoring + Shortlists
# ============================================================
cat("\n====================\nStage 4: scoring\n====================\n")
# ---- Targets / tolerances (edit here) ----
omega_pref    <- c(0.62, 0.65)
omega_hard_hi <- 0.65
omega_hard_lo <- 0.60
omega_center  <- 0.64
gate_omega_max <- 0.67
sigma_pref_max <- 2.35
sigma_soft_max <- 2.50
lambda_center <- 0.50
lambda_soft   <- c(0.20, 0.80)
rF_root_pref  <- c(0.01, 0.12)
rF_root_soft  <- c(0.00, 0.15)
# ---- Gates (strict by default, but we export relaxed too) ----
gate_RH_required      <- TRUE
gate_complex_required <- TRUE
gate_hopf_required    <- FALSE  # keep FALSE unless you want ONLY hopf-verified
# ---- Weights (edit here) ----
w_omega  <- 8.0
w_sigma  <- 1.0
w_lambda <- 1.2
w_hopf   <- 2.5
w_dist   <- 2.0
w_RH     <- 50.0
w_cx     <- 25.0
df_scored <- df %>%
mutate(
# omega penalty: asymmetric, punish >0.65 hard
pen_omega = case_when(
omega_star >= omega_pref[1] & omega_star <= omega_pref[2] ~ 0,
omega_star > omega_hard_hi ~ 5 + 50*(omega_star - omega_hard_hi),
omega_star < omega_hard_lo ~ 2 + 20*(omega_hard_lo - omega_star),
TRUE ~ abs(omega_star - omega_center)
),
pen_sigma = case_when(
sigma <= sigma_pref_max ~ 0,
sigma <= sigma_soft_max ~ (sigma - sigma_pref_max),
TRUE ~ 2 + 5*(sigma - sigma_soft_max)
),
pen_lambda = case_when(
lambda_star >= lambda_soft[1] & lambda_star <= lambda_soft[2] ~ abs(lambda_star - lambda_center),
TRUE ~ 2 + 5*abs(lambda_star - lambda_center)
),
pen_hopf = case_when(
has_hopf & rF_root_med >= rF_root_pref[1] & rF_root_med <= rF_root_pref[2] ~ 0,
has_hopf & rF_root_med >= rF_root_soft[1] & rF_root_med <= rF_root_soft[2] ~ abs(rF_root_med - median(rF_root_pref)),
has_hopf ~ 2 + 5*abs(rF_root_med - median(rF_root_pref)),
TRUE ~ 10
),
pen_dist = case_when(
has_hopf ~ abs(rF - rF_root_med),
TRUE ~ 1
),
# IMPORTANT: vector-safe booleans (NO isTRUE() here)
pen_RH = ifelse(RH_ok == TRUE, 0, 1),
pen_cx = ifelse(has_complex == TRUE, 0, 1),
score = w_omega*pen_omega + w_sigma*pen_sigma + w_lambda*pen_lambda +
w_hopf*pen_hopf + w_dist*pen_dist + w_RH*pen_RH + w_cx*pen_cx
) %>%
arrange(score)
write_csv(df_scored, file.path(dir_stage4, "stage4_scored_candidates.csv"))
# Diagnostics: how many pass each gate individually
gate_diag <- tibble(
n_total = nrow(df_scored),
n_RH_ok = sum(df_scored$RH_ok == TRUE, na.rm = TRUE),
n_complex = sum(df_scored$has_complex == TRUE, na.rm = TRUE),
n_hopf = sum(df_scored$has_hopf == TRUE, na.rm = TRUE),
n_omega_le_cap = sum(df_scored$omega_star <= gate_omega_max, na.rm = TRUE)
)
write_csv(gate_diag, file.path(dir_stage4, "gate_diagnostics.csv"))
print(gate_diag)
# Strict gated shortlist
df_gated_strict <- df_scored %>%
filter(if (gate_RH_required) RH_ok == TRUE else TRUE) %>%
filter(if (gate_complex_required) has_complex == TRUE else TRUE) %>%
filter(if (gate_hopf_required) has_hopf == TRUE else TRUE) %>%
filter(is.finite(omega_star) & omega_star <= gate_omega_max)
# Relaxed gated shortlist (fallback): only omega cap + hopf preferred in score
df_gated_relaxed <- df_scored %>%
filter(is.finite(omega_star) & omega_star <= gate_omega_max)
write_csv(df_gated_strict,  file.path(dir_stage4, "stage4_scored_candidates_GATED_STRICT.csv"))
write_csv(df_gated_relaxed, file.path(dir_stage4, "stage4_scored_candidates_GATED_RELAXED.csv"))
cat("Stage 4 gated sizes:\n")
cat("  strict  =", nrow(df_gated_strict), "\n")
cat("  relaxed =", nrow(df_gated_relaxed), "\n")
pick_cols <- c(
"try_id","cand_id",
"sigma","g_n","i","delta","kappa_max",
"psi","phi2","rF",
"omega_star","d_star",
"lambda_star","f_star","Z_star",
"stable","RH_ok","has_complex",
"has_hopf","n_roots","rF_root_med","rF_root_p25","rF_root_p75",
"pen_omega","pen_sigma","pen_lambda","pen_hopf","pen_dist",
"score"
)
short_top50_all <- df_scored %>% select(any_of(pick_cols)) %>% slice_head(n = 50)
short_top50_rel <- df_gated_relaxed %>% select(any_of(pick_cols)) %>% slice_head(n = 50)
short_top50_str <- df_gated_strict %>% select(any_of(pick_cols)) %>% slice_head(n = 50)
write_csv(short_top50_all, file.path(dir_stage4, "stage4_shortlist_top50_ALL.csv"))
write_csv(short_top50_rel, file.path(dir_stage4, "stage4_shortlist_top50_GATED_RELAXED.csv"))
write_csv(short_top50_str, file.path(dir_stage4, "stage4_shortlist_top50_GATED_STRICT.csv"))
# Plots (simple ggplot + ggsave)
df_plot <- df_scored %>% mutate(score_decile = ntile(score, 10) %>% as.factor())
p1 <- ggplot(df_plot, aes(x = sigma, y = omega_star, color = score_decile)) +
geom_point(alpha = 0.75) +
geom_hline(yintercept = omega_pref, linetype = "dashed") +
labs(title = "Stage 4: omega* vs sigma (score deciles)", x = "sigma", y = "omega*") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_scatter_omega_sigma.png"), p1, width = 10, height = 6, dpi = 160)
p2 <- ggplot(df_plot %>% filter(has_hopf), aes(x = rF_root_med, y = phi2, color = score_decile)) +
geom_point(alpha = 0.75) +
facet_grid(psi ~ kappa_max) +
geom_vline(xintercept = rF_root_pref, linetype = "dashed") +
labs(title = "Stage 4: Hopf boundary locations (rF_root_med vs phi2)",
x = "rF_root (median)", y = "phi2") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_hopf_boundary_phi2.png"), p2, width = 12, height = 8, dpi = 160)
p3 <- ggplot(df_plot, aes(x = score)) +
geom_histogram(bins = 50, alpha = 0.75) +
labs(title = "Stage 4: score distribution", x = "score (lower=better)", y = "count") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_hist.png"), p3, width = 10, height = 5, dpi = 160)
p4 <- ggplot(df_plot, aes(x = omega_star)) +
geom_histogram(bins = 40, alpha = 0.75) +
geom_vline(xintercept = omega_pref, linetype = "dashed") +
labs(title = "Stage 4: omega* distribution", x = "omega*", y = "count") +
theme_minimal()
ggsave(file.path(dir_stage4, "omega_hist.png"), p4, width = 10, height = 5, dpi = 160)
# LaTeX table (top 20, relaxed gated) rounded to 2 decimals
# Requires: \usepackage{booktabs} and if using [H], \usepackage{float}
short_tex <- df_gated_relaxed %>%
select(try_id, cand_id, psi, kappa_max, sigma, omega_star, rF, has_hopf, rF_root_med, score) %>%
slice_head(n = 20) %>%
mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
mutate(has_hopf = ifelse(has_hopf == TRUE, "T", "F"))
cols  <- names(short_tex)
align <- paste(rep("l", length(cols)), collapse = "")
header <- paste(cols, collapse = " & ")
rows <- apply(short_tex, 1, function(r) paste(r, collapse = " & "))
rows <- paste0(rows, " \\\\")
tex_lines <- c(
"\\begin{table}[H]",
"\\centering",
"\\caption{Stage 4 shortlist (top 20 by score; rounded to 2 decimals).}",
"\\label{tab:stage4_shortlist_top20}",
paste0("\\begin{tabular}{", align, "}"),
"\\toprule",
paste0(header, " \\\\"),
"\\midrule",
rows,
"\\bottomrule",
"\\end{tabular}",
"\\end{table}"
)
writeLines(tex_lines, file.path(dir_stage4, "shortlist_top20.tex"))
# ============================================================
# STAGE 5: Hopf-centered simulation sweep + cycle diagnostics
# ============================================================
cat("\n====================\nStage 5: simulation sweep\n====================\n")
# ---- SIM SETTINGS (edit here) ----
sim_t_end <- 800
sim_dt    <- 0.05
burn_frac <- 0.50   # fraction of time to drop as burn-in
rF_eps    <- 0.005  # simulate around Hopf boundary: root +/- eps
n_plan_candidates <- 30  # how many candidates (from Stage 4) to plan sims for
# ---- USER HOOK: define your simulation function here ----
# Must return a data.frame/tibble with columns: time, e, omega, d
# And it must accept (row, rF_sim, t_end, dt).
#
# Example skeleton:
# simulate_model <- function(row, rF_sim, t_end, dt) {
#   # ... use deSolve::ode or your own integrator ...
#   # return tibble(time=..., e=..., omega=..., d=...)
# }
#
# For now we stop if not defined.
if (!exists("simulate_model")) {
cat("\nERROR: You must define simulate_model(row, rF_sim, t_end, dt) before Stage 5 can run.\n")
cat("Create it above this block (or source it), then re-run.\n\n")
} else {
# Candidate pool: use relaxed gated (omega cap) and prioritize hopf existence in score
cand_pool <- df_gated_relaxed %>%
arrange(score) %>%
slice_head(n = n_plan_candidates) %>%
mutate(pool_rank = row_number())
# Build simulation plan:
# - If hopf exists: rF = root-eps, root, root+eps
# - Else: rF = baseline rF (just to see behavior)
plan <- cand_pool %>%
transmute(
pool_rank,
try_id, cand_id,
psi, kappa_max, sigma, g_n, i, delta,
phi2,
omega_star, d_star, lambda_star,
rF_base = rF,
has_hopf, rF_root_med
) %>%
mutate(
rF_root_med = ifelse(has_hopf == TRUE, rF_root_med, NA_real_)
) %>%
group_by(pool_rank, try_id, cand_id) %>%
group_modify(~{
x <- .x[1,]
if (isTRUE(x$has_hopf) && is.finite(x$rF_root_med)) {
bind_rows(
mutate(x, plan_case="root_minus", rF_sim = x$rF_root_med - rF_eps),
mutate(x, plan_case="root",       rF_sim = x$rF_root_med),
mutate(x, plan_case="root_plus",  rF_sim = x$rF_root_med + rF_eps)
)
} else {
mutate(x, plan_case="baseline", rF_sim = x$rF_base)
}
}) %>%
ungroup() %>%
mutate(sim_id = row_number())
write_csv(plan, file.path(dir_stage5, "stage5_sim_plan.csv"))
cat("Stage 5 plan rows =", nrow(plan), "\n")
# Run sims + diagnostics
sim_metrics <- purrr::map_dfr(seq_len(nrow(plan)), function(j) {
rowj <- plan[j, ]
out <- tryCatch(
simulate_model(row = rowj, rF_sim = rowj$rF_sim, t_end = sim_t_end, dt = sim_dt),
error = function(e) NULL
)
if (is.null(out)) {
return(tibble(
sim_id = rowj$sim_id,
try_id = rowj$try_id, cand_id = rowj$cand_id,
plan_case = rowj$plan_case,
rF_sim = rowj$rF_sim,
ok = FALSE,
reason = "simulate_model_error",
amp_e = NA_real_, amp_omega = NA_real_, amp_d = NA_real_,
peaks_omega = NA_integer_, peaks_e = NA_integer_,
mean_omega = NA_real_
))
}
out <- as_tibble(out)
if (!all(c("time","e","omega","d") %in% names(out))) {
return(tibble(
sim_id = rowj$sim_id,
try_id = rowj$try_id, cand_id = rowj$cand_id,
plan_case = rowj$plan_case,
rF_sim = rowj$rF_sim,
ok = FALSE,
reason = "missing_required_cols_time_e_omega_d",
amp_e = NA_real_, amp_omega = NA_real_, amp_d = NA_real_,
peaks_omega = NA_integer_, peaks_e = NA_integer_,
mean_omega = NA_real_
))
}
# burn-in drop
t_cut <- min(out$time, na.rm = TRUE) + burn_frac * (max(out$time, na.rm = TRUE) - min(out$time, na.rm = TRUE))
out2 <- out %>% filter(time >= t_cut)
tibble(
sim_id = rowj$sim_id,
try_id = rowj$try_id, cand_id = rowj$cand_id,
plan_case = rowj$plan_case,
rF_sim = rowj$rF_sim,
ok = TRUE,
reason = "ok",
amp_e     = amp(out2$e),
amp_omega = amp(out2$omega),
amp_d     = amp(out2$d),
peaks_omega = count_peaks(out2$omega),
peaks_e     = count_peaks(out2$e),
mean_omega  = mean(out2$omega, na.rm = TRUE)
)
})
write_csv(sim_metrics, file.path(dir_stage5, "stage5_sim_metrics.csv"))
# Cycle shortlist criteria (edit thresholds here)
# - want some oscillation: omega amplitude not tiny + several peaks
omega_amp_min <- 0.01
peaks_min     <- 3
omega_mean_hi <- 0.70  # keep mean omega from going insane
sim_short <- sim_metrics %>%
filter(ok == TRUE) %>%
filter(is.finite(amp_omega), is.finite(peaks_omega), is.finite(mean_omega)) %>%
mutate(
cycle_like = (amp_omega >= omega_amp_min) & (peaks_omega >= peaks_min) & (mean_omega <= omega_mean_hi)
) %>%
arrange(desc(cycle_like), desc(amp_omega), desc(peaks_omega))
write_csv(sim_short, file.path(dir_stage5, "stage5_cycle_shortlist.csv"))
# Plots
pM1 <- ggplot(sim_short, aes(x = amp_omega)) +
geom_histogram(bins = 40, alpha = 0.75) +
labs(title = "Stage 5: omega amplitude distribution (post burn-in)", x = "amp(omega)", y = "count") +
theme_minimal()
ggsave(file.path(dir_stage5, "omega_amplitude_hist.png"), pM1, width = 10, height = 5, dpi = 160)
pM2 <- ggplot(sim_short, aes(x = peaks_omega, y = amp_omega)) +
geom_point(alpha = 0.75) +
labs(title = "Stage 5: cycle strength (peaks vs amplitude)", x = "peaks(omega)", y = "amp(omega)") +
theme_minimal()
ggsave(file.path(dir_stage5, "peaks_vs_amp_omega.png"), pM2, width = 10, height = 6, dpi = 160)
pM3 <- ggplot(sim_short, aes(x = rF_sim, y = amp_omega)) +
geom_point(alpha = 0.75) +
facet_wrap(~ plan_case) +
labs(title = "Stage 5: amp(omega) by rF_sim (cases)", x = "rF_sim", y = "amp(omega)") +
theme_minimal()
ggsave(file.path(dir_stage5, "amp_by_rF_case.png"), pM3, width = 12, height = 6, dpi = 160)
# LaTeX table: top 15 cycle-like runs
# Requires: \usepackage{booktabs} and if using [H], \usepackage{float}
top_tex <- sim_short %>%
filter(cycle_like == TRUE) %>%
slice_head(n = 15) %>%
select(sim_id, try_id, cand_id, plan_case, rF_sim, amp_omega, peaks_omega, mean_omega) %>%
mutate(across(where(is.numeric), ~ round(.x, 3)))
cols2  <- names(top_tex)
align2 <- paste(rep("l", length(cols2)), collapse = "")
header2 <- paste(cols2, collapse = " & ")
rows2 <- apply(top_tex, 1, function(r) paste(r, collapse = " & "))
rows2 <- paste0(rows2, " \\\\")
tex2 <- c(
"\\begin{table}[H]",
"\\centering",
"\\caption{Stage 5 cycle-like simulations (top 15).}",
"\\label{tab:stage5_cycle_shortlist}",
paste0("\\begin{tabular}{", align2, "}"),
"\\toprule",
paste0(header2, " \\\\"),
"\\midrule",
rows2,
"\\bottomrule",
"\\end{tabular}",
"\\end{table}"
)
writeLines(tex2, file.path(dir_stage5, "table_stage5_cycle_shortlist.tex"))
# Manifest (stage4+stage5)
manifest45 <- tibble(
path = list.files(base_dir, recursive = TRUE, full.names = TRUE)
) %>%
mutate(bytes = file.size(path), ext = tools::file_ext(path)) %>%
arrange(path)
write_csv(manifest45, file.path(base_dir, "manifest_outputs_stage4_5.csv"))
cat("\nStage 5 done.\n")
cat("  plan:    ", file.path(dir_stage5, "stage5_sim_plan.csv"), "\n", sep="")
cat("  metrics: ", file.path(dir_stage5, "stage5_sim_metrics.csv"), "\n", sep="")
cat("  shortlist:", file.path(dir_stage5, "stage5_cycle_shortlist.csv"), "\n", sep="")
cat("  latex:   ", file.path(dir_stage5, "table_stage5_cycle_shortlist.tex"), "\n", sep="")
}
# Stage 4 manifest
manifest4 <- tibble(path = list.files(dir_stage4, full.names = TRUE)) %>%
mutate(bytes = file.size(path), ext = tools::file_ext(path)) %>%
arrange(path)
write_csv(manifest4, file.path(dir_stage4, "manifest_stage4.csv"))
cat("\n====================\nStage 4+5: complete\n====================\n")
