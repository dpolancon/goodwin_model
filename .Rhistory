w_RH     * pen_RH +
w_cx     * pen_cx
) %>%
arrange(score)
# Export full scored table
write_csv(df_scored, file.path(dir_stage4, "stage4_scored_candidates.csv"))
# ----------------------------
# Apply gates (for shortlist set)
# ----------------------------
df_gated <- df_scored %>%
filter(if (gate_RH_required) isTRUE(RH_ok) else TRUE) %>%
filter(if (gate_complex_required) isTRUE(has_complex) else TRUE) %>%
filter(if (gate_hopf_required) isTRUE(has_hopf) else TRUE) %>%
filter(is.finite(omega_star) & omega_star <= gate_omega_max)
write_csv(df_gated, file.path(dir_stage4, "stage4_scored_candidates_GATED.csv"))
cat("\nGated set size =", nrow(df_gated), "\n")
# If gated set is empty, export a diagnostic counts table
gate_diag <- tibble(
n_total = nrow(df_scored),
n_RH_ok = sum(df_scored$RH_ok, na.rm = TRUE),
n_complex = sum(df_scored$has_complex, na.rm = TRUE),
n_hopf = sum(df_scored$has_hopf, na.rm = TRUE),
n_omega_le_cap = sum(df_scored$omega_star <= gate_omega_max, na.rm = TRUE)
)
write_csv(gate_diag, file.path(dir_stage4, "gate_diagnostics.csv"))
# ----------------------------
# Shortlists
# ----------------------------
pick_cols <- c(
"try_id","cand_id",
"sigma","g_n","i","delta","kappa_max",
"psi","phi2","rF",
"omega_star","d_star",
"lambda_star","f_star","Z_star",
"stable","RH_ok","has_complex",
"has_hopf","n_roots","rF_root_med","rF_root_p25","rF_root_p75",
"pen_omega","pen_sigma","pen_lambda","pen_hopf","pen_dist",
"score"
)
short_top20_all <- df_scored %>% select(any_of(pick_cols)) %>% slice_head(n = 20)
short_top50_all <- df_scored %>% select(any_of(pick_cols)) %>% slice_head(n = 50)
short_top20_gated <- df_gated %>% select(any_of(pick_cols)) %>% slice_head(n = 20)
short_top50_gated <- df_gated %>% select(any_of(pick_cols)) %>% slice_head(n = 50)
# Add suggested sim rF values (if Hopf exists)
short_top20_gated <- short_top20_gated %>%
mutate(
rF_sim_low  = ifelse(isTRUE(has_hopf), rF_root_med - rF_eps, NA_real_),
rF_sim_high = ifelse(isTRUE(has_hopf), rF_root_med + rF_eps, NA_real_)
)
write_csv(short_top20_all,   file.path(dir_stage4, "stage4_shortlist_top20_ALL.csv"))
write_csv(short_top50_all,   file.path(dir_stage4, "stage4_shortlist_top50_ALL.csv"))
write_csv(short_top20_gated, file.path(dir_stage4, "stage4_shortlist_top20_GATED.csv"))
write_csv(short_top50_gated, file.path(dir_stage4, "stage4_shortlist_top50_GATED.csv"))
cat("\nTop 10 (GATED) candidates (by score):\n")
print(short_top20_gated %>% slice_head(n = 10))
# ----------------------------
# Plots
# ----------------------------
df_plot <- df_scored %>% mutate(score_decile = ntile(score, 10) %>% as.factor())
pA <- ggplot(df_plot, aes(x = sigma, y = omega_star, color = score_decile)) +
geom_point(alpha = 0.75) +
geom_hline(yintercept = omega_pref, linetype = "dashed") +
labs(title = "Stage 4: omega* vs sigma (score deciles)", x = "sigma", y = "omega*") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_scatter_omega_sigma.png"), pA, width = 10, height = 6, dpi = 160)
pB <- ggplot(df_plot %>% filter(has_hopf), aes(x = rF_root_med, y = phi2, color = score_decile)) +
geom_point(alpha = 0.75) +
facet_grid(psi ~ kappa_max) +
geom_vline(xintercept = rF_root_pref, linetype = "dashed") +
labs(title = "Stage 4: Hopf boundary locations (rF_root_med vs phi2)", x = "rF_root (median)", y = "phi2") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_hopf_boundary_phi2.png"), pB, width = 12, height = 8, dpi = 160)
pC <- ggplot(df_plot, aes(x = score)) +
geom_histogram(bins = 50, alpha = 0.75) +
labs(title = "Stage 4: score distribution", x = "score (lower = better)", y = "count") +
theme_minimal()
ggsave(file.path(dir_stage4, "score_hist.png"), pC, width = 10, height = 5, dpi = 160)
pD <- ggplot(df_plot, aes(x = pen_omega, y = pen_sigma)) +
geom_point(alpha = 0.65) +
labs(title = "Stage 4: penalty trade-off (omega vs sigma)", x = "penalty omega", y = "penalty sigma") +
theme_minimal()
ggsave(file.path(dir_stage4, "penalty_tradeoff_omega_sigma.png"), pD, width = 10, height = 6, dpi = 160)
pE <- ggplot(df_plot, aes(x = omega_star)) +
geom_histogram(bins = 40, alpha = 0.75) +
geom_vline(xintercept = omega_pref, linetype = "dashed") +
labs(title = "Stage 4: omega* distribution", x = "omega*", y = "count") +
theme_minimal()
ggsave(file.path(dir_stage4, "omega_hist.png"), pE, width = 10, height = 5, dpi = 160)
# ----------------------------
# LaTeX table exports (simple, booktabs)
# - Rounds to 2 decimals as requested
# - Uses fewer columns to avoid exploding the page
# Requires in LaTeX: \usepackage{booktabs} and if using [H], also \usepackage{float}
# ----------------------------
short_tex <- short_top20_gated %>%
select(try_id, cand_id, psi, kappa_max, sigma, omega_star, rF, has_hopf, rF_root_med, rF_sim_low, rF_sim_high, score) %>%
mutate(across(where(is.numeric), ~ round(.x, 2))) %>%
mutate(
has_hopf = ifelse(isTRUE(has_hopf), "T", "F")
)
cols <- names(short_tex)
align <- paste(rep("l", length(cols)), collapse = "")
header <- paste(cols, collapse = " & ")
rows <- apply(short_tex, 1, function(r) paste(r, collapse = " & "))
rows <- paste0(rows, " \\\\")
tex_lines <- c(
"\\begin{table}[H]",
"\\centering",
"\\caption{Stage 4 shortlist (top 20 by score, gated; rounded to 2 decimals).}",
"\\label{tab:stage4_shortlist_top20_gated}",
paste0("\\begin{tabular}{", align, "}"),
"\\toprule",
paste0(header, " \\\\"),
"\\midrule",
rows,
"\\bottomrule",
"\\end{tabular}",
"\\end{table}"
)
writeLines(tex_lines, file.path(dir_stage4, "shortlist_top20_GATED.tex"))
# ----------------------------
# Manifest (stage4 only)
# ----------------------------
manifest4 <- tibble(
path = list.files(dir_stage4, recursive = TRUE, full.names = TRUE)
) %>%
mutate(
bytes = file.size(path),
ext   = tools::file_ext(path)
) %>%
arrange(path)
write_csv(manifest4, file.path(dir_stage4, "manifest_stage4.csv"))
cat("\n====================\nStage 4 outputs (dir_stage4)\n====================\n")
print(manifest4)
cat("\nSaved:\n",
"  ", file.path(dir_stage4, "stage4_scored_candidates.csv"), "\n",
"  ", file.path(dir_stage4, "stage4_scored_candidates_GATED.csv"), "\n",
"  ", file.path(dir_stage4, "stage4_shortlist_top20_ALL.csv"), "\n",
"  ", file.path(dir_stage4, "stage4_shortlist_top20_GATED.csv"), "\n",
"  ", file.path(dir_stage4, "shortlist_top20_GATED.tex"), "\n",
"  ", file.path(dir_stage4, "manifest_stage4.csv"), "\n", sep = "")
######
readr::read_csv("outputs/wealth_goodwin/grid_search/stage4_scoring/gate_diagnostics.csv", show_col_types = FALSE)
df_scored %>%
mutate(
ok_RH = isTRUE(RH_ok),
ok_cx = isTRUE(has_complex),
ok_om = omega_star <= gate_omega_max,
ok_hopf = isTRUE(has_hopf)
) %>%
count(ok_RH, ok_cx, ok_om, ok_hopf) %>%
arrange(desc(n))
hopf_by_cand <- hopf_verified %>%
filter(is.finite(rF0)) %>%
group_by(try_id, cand_id, rF0) %>%
summarise(
n_roots = n(),
rF_root_med = median(rF_root, na.rm = TRUE),
rF_root_p25 = quantile(rF_root, 0.25, na.rm = TRUE),
rF_root_p75 = quantile(rF_root, 0.75, na.rm = TRUE),
maxIm_root_med = if ("maxIm_root" %in% names(.)) median(maxIm_root, na.rm = TRUE) else NA_real_,
.groups = "drop"
)
hopf_by_cand <- hopf_by_cand %>%
mutate(hopf_complex = is.finite(maxIm_root_med) & maxIm_root_med > 1e-5)
# ============================================================
# STAGE 5: SIMULATION (NUKED + SAFEGUARDS)
# - Never marks cycles if unbounded
# - Always writes Stage 5B/5C/5D outputs (schema-safe)
# - Robust to empty targets and missing columns
# - Uses simulate_model hook if available
# ============================================================
suppressPackageStartupMessages({
library(dplyr)
library(tidyr)
library(purrr)
library(readr)
library(tibble)
})
# ----------------------------
# Safe CSV writer (schema-friendly)
# ----------------------------
write_csv_safe <- function(df, path) {
dir.create(dirname(path), showWarnings = FALSE, recursive = TRUE)
if (is.null(df)) df <- tibble::tibble()
readr::write_csv(df, path)
invisible(path)
}
# ----------------------------
# Vector-safe logical coercion
# ----------------------------
as_logi <- function(x) {
if (is.logical(x)) return(x)
if (is.numeric(x)) return(x != 0)
if (is.character(x)) return(toupper(x) %in% c("TRUE","T","1","YES","Y"))
rep(FALSE, length(x))
}
# ----------------------------
# simulate_model wrapper: supports optional x0
# ----------------------------
call_simulate_model <- function(row, rF_sim, t_end, dt, x0 = NULL) {
fm <- names(formals(simulate_model))
if (!is.null(x0) && "x0" %in% fm) {
simulate_model(row, rF_sim = rF_sim, t_end = t_end, dt = dt, x0 = x0)
} else {
simulate_model(row, rF_sim = rF_sim, t_end = t_end, dt = dt)
}
}
# ----------------------------
# Boundedness: return BOTH ok + reason (helps diagnosis)
# ----------------------------
bounded_report <- function(sim,
e_rng = c(0, 1.5),
omega_rng = c(0, 1.5),
d_rng = c(-0.1, 10)) {
sim <- tibble::as_tibble(sim)
req <- c("time","e","omega","d")
if (!all(req %in% names(sim))) {
return(list(ok = FALSE, reason = "missing_required_cols"))
}
# nonfinite?
if (any(!is.finite(sim$e)) || any(!is.finite(sim$omega)) || any(!is.finite(sim$d))) {
return(list(ok = FALSE, reason = "nonfinite_values"))
}
# range checks
if (min(sim$e) < e_rng[1] || max(sim$e) > e_rng[2]) {
return(list(ok = FALSE, reason = "e_out_of_bounds"))
}
if (min(sim$omega) < omega_rng[1] || max(sim$omega) > omega_rng[2]) {
return(list(ok = FALSE, reason = "omega_out_of_bounds"))
}
if (min(sim$d) < d_rng[1] || max(sim$d) > d_rng[2]) {
return(list(ok = FALSE, reason = "d_out_of_bounds"))
}
list(ok = TRUE, reason = "ok")
}
bounded_ok <- function(sim, ...) {
bounded_report(sim, ...)$ok
}
# ----------------------------
# Cycle metrics: NEVER cycle if unbounded
# - requires enough peaks for a period estimate
# - constant schema always
# ----------------------------
cycle_metrics <- function(sim,
burn_in,
var_min,
amp_min,
bounded = TRUE,
min_peaks = 4) {
sim2 <- tibble::as_tibble(sim) %>%
dplyr::filter(.data$time >= burn_in)
out <- function(has_cycle, reason,
v = NA_real_, a = NA_real_, per = NA_real_, om = NA_real_, n_peaks = NA_integer_) {
tibble::tibble(
has_cycle = has_cycle,
reason = reason,
var = v,
amp = a,
period = per,
omega_mean = om,
n_peaks = n_peaks
)
}
if (!all(c("time","omega") %in% names(sim2))) return(out(FALSE, "missing_omega_or_time"))
# hard rule
if (!isTRUE(bounded)) return(out(FALSE, "unbounded_path"))
x <- sim2$omega
t <- sim2$time
v  <- stats::var(x, na.rm = TRUE)
a  <- (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)) / 2
om <- mean(x, na.rm = TRUE)
if (!is.finite(v) || !is.finite(a) || !is.finite(om)) return(out(FALSE, "nonfinite", v, a, NA_real_, om))
if (v < var_min || a < amp_min) return(out(FALSE, "low_var_or_amp", v, a, NA_real_, om))
dx <- diff(x)
peaks <- which(head(dx, -1) > 0 & tail(dx, -1) <= 0) + 1
if (length(peaks) < min_peaks) return(out(FALSE, "too_few_peaks", v, a, NA_real_, om, length(peaks)))
periods <- diff(t[peaks])
per <- mean(periods, na.rm = TRUE)
if (!is.finite(per) || per <= 0) return(out(FALSE, "bad_period", v, a, per, om, length(peaks)))
out(TRUE, "ok", v, a, per, om, length(peaks))
}
# ============================================================
# run_stage5 (NUKED + SAFEGUARDS)
# ============================================================
run_stage5 <- function(cfg, dirs) {
cat("\n====================\nStage 5: simulation\n====================\n")
set.seed(cfg$stage5$seed_stage5)
# Ensure stage folders exist
dir.create(dirs$stage5A, showWarnings = FALSE, recursive = TRUE)
dir.create(dirs$stage5B, showWarnings = FALSE, recursive = TRUE)
dir.create(dirs$stage5C, showWarnings = FALSE, recursive = TRUE)
dir.create(dirs$stage5D, showWarnings = FALSE, recursive = TRUE)
# Try to source hook if missing
if (!exists("simulate_model")) {
if (!is.null(cfg$stage5$hook_path) && file.exists(cfg$stage5$hook_path)) {
source(cfg$stage5$hook_path)
}
}
# If still missing, write empties and exit
if (!exists("simulate_model")) {
msg <- "Stage 5 requires simulate_model(row, rF_sim, t_end, dt[, x0]) -> tibble(time,e,omega,d)"
if (isTRUE(cfg$stage5$require_simulate_hook)) stop(msg)
cat("Skipping Stage 5 (hook missing): ", msg, "\n", sep = "")
write_csv_safe(tibble::tibble(), file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
write_csv_safe(tibble::tibble(
candidate_id = integer(),
survival_rate = double(),
bounded_rate  = double(),
cycle_rate    = double(),
amp_med       = double(),
period_med    = double()
), file.path(dirs$stage5C, "robustness_summary.csv"))
write_csv_safe(tibble::tibble(), file.path(dirs$stage5D, "stage5_final_ranked.csv"))
write_csv_safe(tibble::tibble(), file.path(dirs$stage5D, "stage5_top20.csv"))
return(invisible(NULL))
}
# Candidate pool (prefer Stage 4 relaxed shortlist; fallback progressively)
cand_pool_file <- file.path(dirs$stage4, "stage4_shortlist_top50_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates.csv")
stopifnot(file.exists(cand_pool_file))
cand <- readr::read_csv(cand_pool_file, show_col_types = FALSE) %>%
dplyr::slice_head(n = cfg$stage5$n_candidates) %>%
dplyr::mutate(candidate_id = dplyr::row_number())
write_csv_safe(cand, file.path(dirs$stage5A, "stage5_candidate_pool.csv"))
# Root seed selection: rF_root_med if present else rF
cand_5A <- cand %>%
dplyr::mutate(
rF_seed = dplyr::case_when(
"rF_root_med" %in% names(.) & is.finite(.data$rF_root_med) ~ as.numeric(.data$rF_root_med),
TRUE ~ as.numeric(.data$rF)
),
rF_root = .data$rF_seed
)
write_csv_safe(cand_5A, file.path(dirs$stage5A, "stage5A_hopf_certified.csv"))
# -----------------------------------------
# 5B: simulate below/above root and compute metrics
# -----------------------------------------
sim_5B <- cand_5A %>%
dplyr::mutate(
sim = purrr::pmap(., function(...) {
row <- tibble::tibble(...)
id  <- as.character(row$candidate_id)
rF_root <- suppressWarnings(as.numeric(row$rF_root))
if (!is.finite(rF_root)) rF_root <- suppressWarnings(as.numeric(row$rF_seed))
rF_lo <- max(1e-6, rF_root - cfg$stage5$eps_root)
rF_hi <- rF_root + cfg$stage5$eps_root
# initial condition suggestion
x0 <- c(e = 0.90, omega = 0.65, d = 0.5) + cfg$stage5$perturb
if (all(c("e_star","omega_star","d_star") %in% names(row))) {
x0 <- c(e = row$e_star, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
} else if (all(c("omega_star","d_star") %in% names(row))) {
x0 <- c(e = cfg$targets$e_target, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
}
sim_lo <- tryCatch(
call_simulate_model(row, rF_sim = rF_lo, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL
)
sim_hi <- tryCatch(
call_simulate_model(row, rF_sim = rF_hi, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL
)
if (is.null(sim_lo) || is.null(sim_hi)) {
return(tibble::tibble(
sim_ok = FALSE, sim_reason = "simulate_model_error",
bounded_below = FALSE, bounded_above = FALSE,
bounded_reason_below = "simulate_model_error",
bounded_reason_above = "simulate_model_error",
has_cycle_below = FALSE, has_cycle_above = FALSE,
amp_below = NA_real_, amp_above = NA_real_,
period_below = NA_real_, period_above = NA_real_,
omega_mean_above = NA_real_,
rF_lo = rF_lo, rF_hi = rF_hi
))
}
sim_lo <- tibble::as_tibble(sim_lo)
sim_hi <- tibble::as_tibble(sim_hi)
write_csv_safe(sim_lo, file.path(dirs$stage5B, paste0("traj_", id, "_below.csv")))
write_csv_safe(sim_hi, file.path(dirs$stage5B, paste0("traj_", id, "_above.csv")))
br_lo <- bounded_report(sim_lo)
br_hi <- bounded_report(sim_hi)
met_lo <- cycle_metrics(sim_lo,
burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min,
amp_min = cfg$stage5$amp_min,
bounded = br_lo$ok,
min_peaks = cfg$stage5$min_peaks)
met_hi <- cycle_metrics(sim_hi,
burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min,
amp_min = cfg$stage5$amp_min,
bounded = br_hi$ok,
min_peaks = cfg$stage5$min_peaks)
tibble::tibble(
sim_ok = TRUE, sim_reason = "ok",
bounded_below = br_lo$ok,
bounded_above = br_hi$ok,
bounded_reason_below = br_lo$reason,
bounded_reason_above = br_hi$reason,
has_cycle_below = met_lo$has_cycle,
has_cycle_above = met_hi$has_cycle,
amp_below = met_lo$amp,
amp_above = met_hi$amp,
period_below = met_lo$period,
period_above = met_hi$period,
omega_mean_above = met_hi$omega_mean,
rF_lo = rF_lo, rF_hi = rF_hi
)
})
) %>%
tidyr::unnest(sim)
write_csv_safe(sim_5B, file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
# -----------------------------------------
# 5C: robustness ring (only bounded + cycle above)
# -----------------------------------------
targets <- sim_5B %>%
mutate(
sim_ok = as_logi(sim_ok),
bounded_above = as_logi(bounded_above),
has_cycle_above = as_logi(has_cycle_above)
) %>%
filter(sim_ok, bounded_above, has_cycle_above)
robust_schema <- tibble::tibble(
candidate_id = integer(),
survival_rate = double(),
bounded_rate  = double(),
cycle_rate    = double(),
amp_med       = double(),
period_med    = double()
)
if (nrow(targets) == 0) {
cat("Stage 5C: no bounded cycle candidates above root. Writing empty robustness_summary.\n")
robust_5C <- robust_schema
} else {
robust_5C <- targets %>%
mutate(
robust = purrr::pmap(., function(...) {
row <- tibble::tibble(...)
rF_test <- suppressWarnings(as.numeric(row$rF_root))
if (!is.finite(rF_test)) rF_test <- suppressWarnings(as.numeric(row$rF_seed))
rF_test <- rF_test + cfg$stage5$eps_root
out <- purrr::map_dfr(seq_len(cfg$stage5$robust_reps), function(rep_id) {
rowj <- row
for (nm in cfg$stage5$jitter_cols) {
if (nm %in% names(rowj) && is.finite(rowj[[nm]])) {
rowj[[nm]] <- rowj[[nm]] * exp(rnorm(1, 0, cfg$stage5$jitter_sd))
}
}
sim <- tryCatch(
call_simulate_model(rowj, rF_sim = rF_test, t_end = cfg$stage5$robust_t_end, dt = cfg$stage5$dt),
error = function(e) NULL
)
if (is.null(sim)) {
return(tibble::tibble(rep = rep_id, ok = FALSE, bounded = FALSE, has_cycle = FALSE,
amp = NA_real_, period = NA_real_))
}
sim <- tibble::as_tibble(sim)
br  <- bounded_report(sim)
met <- cycle_metrics(sim,
burn_in = min(cfg$stage5$burn_in, cfg$stage5$robust_t_end / 2),
var_min = cfg$stage5$cycle_var_min,
amp_min = cfg$stage5$amp_min,
bounded = br$ok,
min_peaks = cfg$stage5$min_peaks)
tibble::tibble(
rep = rep_id,
ok = TRUE,
bounded = br$ok,
has_cycle = met$has_cycle,
amp = met$amp,
period = met$period
)
})
tibble::tibble(
survival_rate = mean(out$bounded & out$has_cycle, na.rm = TRUE),
bounded_rate  = mean(out$bounded, na.rm = TRUE),
cycle_rate    = mean(out$has_cycle, na.rm = TRUE),
amp_med       = stats::median(out$amp, na.rm = TRUE),
period_med    = stats::median(out$period, na.rm = TRUE)
)
})
) %>%
tidyr::unnest(robust) %>%
select(candidate_id, survival_rate, bounded_rate, cycle_rate, amp_med, period_med)
# If for some reason it ends empty, enforce schema
if (nrow(robust_5C) == 0) robust_5C <- robust_schema
}
write_csv_safe(robust_5C, file.path(dirs$stage5C, "robustness_summary.csv"))
# -----------------------------------------
# 5D: final ranking (ALWAYS produced)
# -----------------------------------------
final_5D <- sim_5B %>%
left_join(robust_5C, by = "candidate_id") %>%
mutate(
survival_rate = dplyr::coalesce(as.numeric(survival_rate), 0),
bounded_rate  = dplyr::coalesce(as.numeric(bounded_rate), 0),
cycle_rate    = dplyr::coalesce(as.numeric(cycle_rate), 0),
amp_above_num = suppressWarnings(as.numeric(amp_above)),
score_stage5  = 3 * survival_rate + 1 * bounded_rate + 1 * cycle_rate +
0.2 * if_else(is.finite(amp_above_num), pmin(amp_above_num, 1), 0)
) %>%
arrange(desc(score_stage5))
write_csv_safe(final_5D, file.path(dirs$stage5D, "stage5_final_ranked.csv"))
write_csv_safe(final_5D %>% slice_head(n = 20), file.path(dirs$stage5D, "stage5_top20.csv"))
cat("\nStage 5 complete.\n")
cat("  5A: ", file.path(dirs$stage5A, "stage5A_hopf_certified.csv"), "\n", sep = "")
cat("  5B: ", file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"), "\n", sep = "")
cat("  5C: ", file.path(dirs$stage5C, "robustness_summary.csv"), "\n", sep = "")
cat("  5D: ", file.path(dirs$stage5D, "stage5_final_ranked.csv"), "\n", sep = "")
invisible(final_5D)
}
