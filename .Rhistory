if (!exists("simulate_model")) {
if (file.exists(cfg$stage5$hook_path)) source(cfg$stage5$hook_path)
}
if (!exists("simulate_model")) {
msg <- "Stage 5 requires simulate_model(row, rF_sim, t_end, dt) -> columns: time,e,omega,d"
if (isTRUE(cfg$stage5$require_simulate_hook)) stop(msg)
cat("Skipping Stage 5 (hook missing): ", msg, "\n", sep="")
write_csv_safe(tibble(), file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
write_csv_safe(tibble(), file.path(dirs$stage5C, "robustness_summary.csv"))
write_csv_safe(tibble(), file.path(dirs$stage5D, "stage5_final_ranked.csv"))
return(invisible(NULL))
}
# Candidate pool (prefer Stage 4 relaxed shortlist)
cand_pool_file <- file.path(dirs$stage4, "stage4_shortlist_top50_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates.csv")
stopifnot(file.exists(cand_pool_file))
cand <- read_csv(cand_pool_file, show_col_types = FALSE) %>%
slice_head(n = cfg$stage5$n_candidates) %>%
mutate(candidate_id = row_number())
write_csv_safe(cand, file.path(dirs$stage5A, "stage5_candidate_pool.csv"))
# Root seed selection: rF_root_med if present else rF
cand_5A <- cand %>%
mutate(
rF_seed = case_when(
"rF_root_med" %in% names(.) & is.finite(rF_root_med) ~ as.numeric(rF_root_med),
TRUE ~ as.numeric(rF)
),
rF_root = rF_seed
)
write_csv_safe(cand_5A, file.path(dirs$stage5A, "stage5A_hopf_certified.csv"))
# Sims below/above root
sim_5B <- cand_5A %>%
mutate(
sim = pmap(., function(...) {
row <- tibble(...)
id <- as.character(row$candidate_id)
rF_root <- as.numeric(row$rF_root)
if (!is.finite(rF_root)) rF_root <- as.numeric(row$rF_seed)
rF_lo <- max(1e-6, rF_root - cfg$stage5$eps_root)
rF_hi <- rF_root + cfg$stage5$eps_root
# initial condition suggestion (optional)
x0 <- c(e = 0.90, omega = 0.65, d = 0.5) + cfg$stage5$perturb
if (all(c("e_star","omega_star","d_star") %in% names(row))) {
x0 <- c(e = row$e_star, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
} else if (all(c("omega_star","d_star") %in% names(row))) {
x0 <- c(e = cfg$targets$e_target, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
}
sim_lo <- tryCatch(call_simulate_model(row, rF_sim = rF_lo, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL)
sim_hi <- tryCatch(call_simulate_model(row, rF_sim = rF_hi, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL)
if (is.null(sim_lo) || is.null(sim_hi)) {
return(tibble(
sim_ok = FALSE, sim_reason = "simulate_model_error",
bounded_below = NA, bounded_above = NA,
has_cycle_below = NA, has_cycle_above = NA,
amp_below = NA_real_, amp_above = NA_real_,
period_below = NA_real_, period_above = NA_real_,
omega_mean_above = NA_real_,
rF_lo = rF_lo, rF_hi = rF_hi
))
}
sim_lo <- as_tibble(sim_lo)
sim_hi <- as_tibble(sim_hi)
write_csv_safe(sim_lo, file.path(dirs$stage5B, paste0("traj_", id, "_below.csv")))
write_csv_safe(sim_hi, file.path(dirs$stage5B, paste0("traj_", id, "_above.csv")))
met_lo <- cycle_metrics(sim_lo, burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
met_hi <- cycle_metrics(sim_hi, burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
tibble(
sim_ok = TRUE, sim_reason = "ok",
bounded_below = bounded_ok(sim_lo),
bounded_above = bounded_ok(sim_hi),
has_cycle_below = met_lo$has_cycle %||% FALSE,
has_cycle_above = met_hi$has_cycle %||% FALSE,
amp_below = met_lo$amp %||% NA_real_,
amp_above = met_hi$amp %||% NA_real_,
period_below = met_lo$period %||% NA_real_,
period_above = met_hi$period %||% NA_real_,
omega_mean_above = met_hi$omega_mean %||% NA_real_,
rF_lo = rF_lo, rF_hi = rF_hi
)
})
) %>%
unnest(sim)
write_csv_safe(sim_5B, file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
# Robustness ring
targets <- sim_5B %>%
filter(sim_ok == TRUE, bounded_above == TRUE, has_cycle_above == TRUE)
robust_5C <- targets %>%
mutate(
robust = pmap(., function(...) {
row <- tibble(...)
rF_test <- as.numeric(row$rF_root)
if (!is.finite(rF_test)) rF_test <- as.numeric(row$rF_seed)
rF_test <- rF_test + cfg$stage5$eps_root
out <- map_dfr(seq_len(cfg$stage5$robust_reps), function(rep_id) {
rowj <- row
for (nm in cfg$stage5$jitter_cols) {
if (nm %in% names(rowj) && is.finite(rowj[[nm]])) {
rowj[[nm]] <- rowj[[nm]] * exp(rnorm(1, 0, cfg$stage5$jitter_sd))
}
}
sim <- tryCatch(call_simulate_model(rowj, rF_sim = rF_test, t_end = cfg$stage5$robust_t_end, dt = cfg$stage5$dt),
error=function(e) NULL)
if (is.null(sim)) {
return(tibble(rep = rep_id, ok = FALSE, bounded = FALSE, has_cycle = FALSE, amp = NA_real_, period = NA_real_))
}
sim <- as_tibble(sim)
met <- cycle_metrics(sim, burn_in = min(cfg$stage5$burn_in, cfg$stage5$robust_t_end/2),
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
tibble(
rep = rep_id,
ok = TRUE,
bounded = bounded_ok(sim),
has_cycle = met$has_cycle %||% FALSE,
amp = met$amp %||% NA_real_,
period = met$period %||% NA_real_
)
})
tibble(
survival_rate = mean(out$bounded & out$has_cycle, na.rm = TRUE),
bounded_rate  = mean(out$bounded, na.rm = TRUE),
cycle_rate    = mean(out$has_cycle, na.rm = TRUE),
amp_med       = median(out$amp, na.rm = TRUE),
period_med    = median(out$period, na.rm = TRUE)
)
})
) %>%
unnest(robust)
write_csv_safe(robust_5C, file.path(dirs$stage5C, "robustness_summary.csv"))
# Final ranking
final_5D <- sim_5B %>%
left_join(robust_5C %>% select(candidate_id, survival_rate, bounded_rate, cycle_rate, amp_med, period_med),
by = "candidate_id") %>%
mutate(
survival_rate = coalesce(survival_rate, 0),
bounded_rate  = coalesce(bounded_rate, 0),
cycle_rate    = coalesce(cycle_rate, 0),
score_stage5 = 3*survival_rate + 1*bounded_rate + 1*cycle_rate +
0.2*if_else(is.finite(amp_above), pmin(amp_above, 1), 0)
) %>%
arrange(desc(score_stage5))
write_csv_safe(final_5D, file.path(dirs$stage5D, "stage5_final_ranked.csv"))
write_csv_safe(final_5D %>% slice_head(n = 20), file.path(dirs$stage5D, "stage5_top20.csv"))
cat("\nStage 5 complete.\n")
cat("  5A: ", file.path(dirs$stage5A, "stage5A_hopf_certified.csv"), "\n", sep="")
cat("  5B: ", file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"), "\n", sep="")
cat("  5C: ", file.path(dirs$stage5C, "robustness_summary.csv"), "\n", sep="")
cat("  5D: ", file.path(dirs$stage5D, "stage5_final_ranked.csv"), "\n", sep="")
invisible(final_5D)
}
# ============================================================
# 10) RUN PIPELINE (sequential, restart-friendly)
# ============================================================
out1 <- NULL; out2 <- NULL; out3 <- NULL; out4 <- NULL
if (isTRUE(cfg$run$stage1)) {
out1 <- run_stage1(cfg, dirs, par_base)
}
if (isTRUE(cfg$run$stage2)) {
stage1_ok <- if (!is.null(out1)) out1$stage1_ok else {
read_csv(file.path(dirs$stage1, "stage1_backbone.csv"), show_col_types = FALSE) %>% filter(backbone_ok)
}
out2 <- run_stage2(cfg, dirs, par_base, stage1_ok)
}
if (isTRUE(cfg$run$stage3)) {
stage2_ok <- if (!is.null(out2)) out2$stage2_ok else {
read_csv(file.path(dirs$stage2, "stage2_finance_scan.csv"), show_col_types = FALSE) %>% filter(econ_ok)
}
out3 <- run_stage3(cfg, dirs, par_base, stage2_ok)
}
if (isTRUE(cfg$run$stage4)) {
out4 <- run_stage4(cfg, dirs)
}
if (isTRUE(cfg$run$stage5)) {
run_stage5(cfg, dirs)
}
# ============================================================
# R/hooks/simulate_model.R
# Hook for Stage 5
# Must define: simulate_model(row, rF_sim, t_end, dt, x0=NULL)
# Returns a tibble with columns: time, e, omega, d
# ============================================================
simulate_model <- function(row, rF_sim, t_end, dt, x0 = NULL) {
if (!requireNamespace("deSolve", quietly = TRUE)) {
stop("simulate_model() requires the 'deSolve' package. Install it via install.packages('deSolve').")
}
# row arrives as a 1-row tibble/data.frame from pmap; coerce safely
if (is.data.frame(row)) row <- as.list(row[1, ])
if (!is.list(row)) stop("simulate_model(): 'row' must be list-like (a 1-row tibble/data.frame is fine).")
# ---- Helpers (self-contained) ----
logistic <- function(x) 1 / (1 + exp(-x))
# Pull global defaults if you have them, else fallback
# These match the par_base you showed earlier.
p <- if (exists("par_base", inherits = TRUE)) get("par_base", inherits = TRUE) else list(
kappa_min = 0.02,
kappa_max = 0.25,
kappa0    = 0.10,
kappa1    = 30.0,
phi3      = 8.0,
phi4      = 1.0,
phi0      = -0.02,
alpha     = 0.02,
phi1_min  = 0.10,
phi1_max  = 5.00
)
# Candidate overrides
if (!is.null(row$kappa_max) && is.finite(row$kappa_max)) p$kappa_max <- as.numeric(row$kappa_max)
if (!is.null(row$kappa_min) && is.finite(row$kappa_min)) p$kappa_min <- as.numeric(row$kappa_min)
# Core candidate parameters (must exist)
sigma <- as.numeric(row$sigma)
g_n   <- as.numeric(row$g_n)
i     <- as.numeric(row$i)
delta <- as.numeric(row$delta)
psi  <- as.numeric(row$psi)
phi2 <- as.numeric(row$phi2)
stopifnot(is.finite(sigma), is.finite(g_n), is.finite(i), is.finite(delta),
is.finite(psi), is.finite(phi2), g_n > 0, sigma > 0)
kappa_fun <- function(r) {
p$kappa_min + (p$kappa_max - p$kappa_min) * logistic(p$kappa1 * (r - p$kappa0))
}
Z_fun <- function(d, f) {
logistic(p$phi3 * ((d - 1) + p$phi4 * (f - 1)))
}
lambda_fun <- function(r, rF, psi) logistic(psi * (r - rF))
# ---- Choose phi1 (constant) ----
# Prefer Stage2's phi1_endog if present, else reconstruct from stored Z_star if possible.
e_target <- if (exists("cfg", inherits = TRUE) && !is.null(get("cfg", inherits=TRUE)$targets$e_target)) {
get("cfg", inherits = TRUE)$targets$e_target
} else {
0.94
}
phi1 <- NA_real_
if (!is.null(row$phi1_endog) && is.finite(row$phi1_endog)) {
phi1 <- as.numeric(row$phi1_endog)
} else if (!is.null(row$Z_star) && is.finite(row$Z_star)) {
phi1 <- (p$alpha - p$phi0 + phi2 * as.numeric(row$Z_star)) / e_target
} else {
# last resort: use a sane mid value; dynamics still run
phi1 <- 1.0
}
if (!is.finite(phi1)) phi1 <- 1.0
# ---- Initial conditions ----
if (is.null(x0)) {
# Use steady state if available, else defaults
e0 <- if (!is.null(row$e_star) && is.finite(row$e_star)) as.numeric(row$e_star) else e_target
w0 <- if (!is.null(row$omega_star) && is.finite(row$omega_star)) as.numeric(row$omega_star) else 0.65
d0 <- if (!is.null(row$d_star) && is.finite(row$d_star)) as.numeric(row$d_star) else 0.5
x0 <- c(e = e0, omega = w0, d = d0)
} else {
x0 <- as.numeric(x0)
names(x0) <- names(x0) %||% c("e", "omega", "d")
if (!all(c("e","omega","d") %in% names(x0))) stop("x0 must be a named vector with e, omega, d.")
}
# ---- ODE system (reduced 3D) ----
rhs <- function(t, state, parms) {
e     <- state[["e"]]
omega <- state[["omega"]]
d     <- state[["d"]]
# implied profit rate
r <- (1 - omega - i * d) / sigma
# investment / growth
kappa <- kappa_fun(r)
g     <- kappa / sigma - delta
# financialization block
lam <- lambda_fun(r, rF = rF_sim, psi = psi)
# avoid division blow-ups if lam ~ 1
lam <- min(max(lam, 1e-10), 1 - 1e-10)
iotaF <- r * (lam / (1 - lam))
f     <- iotaF / g_n
# discipline
Z <- Z_fun(d, f)
de     <- (g - g_n) * e
domega <- omega * (p$phi0 + phi1 * e - p$alpha - phi2 * Z)
dd     <- kappa - (1 - omega) + i * d - d * g
list(c(de, domega, dd))
}
times <- seq(0, t_end, by = dt)
sol <- deSolve::ode(
y = x0,
times = times,
func = rhs,
parms = NULL,
method = "lsoda"
)
sol <- as.data.frame(sol)
tibble::as_tibble(sol) %>%
dplyr::rename(time = .data$time) %>%
dplyr::select(time, e, omega, d)
}
call_simulate_model <- function(row, rF_sim, t_end, dt, x0 = NULL) {
# supports either simulate_model(row, rF_sim, t_end, dt)
# or simulate_model(row, rF_sim, t_end, dt, x0)
fm <- names(formals(simulate_model))
if (!is.null(x0) && "x0" %in% fm) {
simulate_model(row, rF_sim = rF_sim, t_end = t_end, dt = dt, x0 = x0)
} else {
simulate_model(row, rF_sim = rF_sim, t_end = t_end, dt = dt)
}
}
cycle_metrics <- function(sim, burn_in, var_min, amp_min) {
sim2 <- as_tibble(sim) %>% filter(time >= burn_in)
if (!("omega" %in% names(sim2))) return(tibble(has_cycle = FALSE, reason = "missing_omega"))
x <- sim2$omega
t <- sim2$time
v <- var(x, na.rm = TRUE)
a <- (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)) / 2
if (!is.finite(v) || !is.finite(a)) return(tibble(has_cycle = FALSE, reason = "nonfinite", var=v, amp=a))
if (v < var_min || a < amp_min) return(tibble(has_cycle = FALSE, reason = "low_var_or_amp", var=v, amp=a))
dx <- diff(x)
peaks <- which(head(dx, -1) > 0 & tail(dx, -1) <= 0) + 1
if (length(peaks) < 3) return(tibble(has_cycle = TRUE, reason = "few_peaks", var=v, amp=a, period=NA_real_))
periods <- diff(t[peaks])
tibble(has_cycle = TRUE, reason = "ok", var=v, amp=a,
period = mean(periods, na.rm = TRUE),
omega_mean = mean(x, na.rm = TRUE))
}
bounded_ok <- function(sim) {
sim <- as_tibble(sim)
ok <- TRUE
if ("e" %in% names(sim))     ok <- ok && all(is.finite(sim$e))     && all(sim$e >= 0)     && all(sim$e <= 1.5)
if ("omega" %in% names(sim)) ok <- ok && all(is.finite(sim$omega)) && all(sim$omega >= 0) && all(sim$omega <= 1.5)
if ("d" %in% names(sim))     ok <- ok && all(is.finite(sim$d))     && all(sim$d >= -0.1)  && all(sim$d <= 10)
ok
}
run_stage5 <- function(cfg, dirs) {
cat("\n====================\nStage 5: simulation\n====================\n")
set.seed(cfg$stage5$seed_stage5)
# try to source hook if missing
if (!exists("simulate_model")) {
if (file.exists(cfg$stage5$hook_path)) source(cfg$stage5$hook_path)
}
if (!exists("simulate_model")) {
msg <- "Stage 5 requires simulate_model(row, rF_sim, t_end, dt) -> columns: time,e,omega,d"
if (isTRUE(cfg$stage5$require_simulate_hook)) stop(msg)
cat("Skipping Stage 5 (hook missing): ", msg, "\n", sep="")
write_csv_safe(tibble(), file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
write_csv_safe(tibble(), file.path(dirs$stage5C, "robustness_summary.csv"))
write_csv_safe(tibble(), file.path(dirs$stage5D, "stage5_final_ranked.csv"))
return(invisible(NULL))
}
# Candidate pool (prefer Stage 4 relaxed shortlist)
cand_pool_file <- file.path(dirs$stage4, "stage4_shortlist_top50_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates_GATED_RELAXED.csv")
if (!file.exists(cand_pool_file)) cand_pool_file <- file.path(dirs$stage4, "stage4_scored_candidates.csv")
stopifnot(file.exists(cand_pool_file))
cand <- read_csv(cand_pool_file, show_col_types = FALSE) %>%
slice_head(n = cfg$stage5$n_candidates) %>%
mutate(candidate_id = row_number())
write_csv_safe(cand, file.path(dirs$stage5A, "stage5_candidate_pool.csv"))
# Root seed selection: rF_root_med if present else rF
cand_5A <- cand %>%
mutate(
rF_seed = case_when(
"rF_root_med" %in% names(.) & is.finite(rF_root_med) ~ as.numeric(rF_root_med),
TRUE ~ as.numeric(rF)
),
rF_root = rF_seed
)
write_csv_safe(cand_5A, file.path(dirs$stage5A, "stage5A_hopf_certified.csv"))
# Sims below/above root
sim_5B <- cand_5A %>%
mutate(
sim = pmap(., function(...) {
row <- tibble(...)
id <- as.character(row$candidate_id)
rF_root <- as.numeric(row$rF_root)
if (!is.finite(rF_root)) rF_root <- as.numeric(row$rF_seed)
rF_lo <- max(1e-6, rF_root - cfg$stage5$eps_root)
rF_hi <- rF_root + cfg$stage5$eps_root
# initial condition suggestion (optional)
x0 <- c(e = 0.90, omega = 0.65, d = 0.5) + cfg$stage5$perturb
if (all(c("e_star","omega_star","d_star") %in% names(row))) {
x0 <- c(e = row$e_star, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
} else if (all(c("omega_star","d_star") %in% names(row))) {
x0 <- c(e = cfg$targets$e_target, omega = row$omega_star, d = row$d_star) + cfg$stage5$perturb
}
sim_lo <- tryCatch(call_simulate_model(row, rF_sim = rF_lo, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL)
sim_hi <- tryCatch(call_simulate_model(row, rF_sim = rF_hi, t_end = cfg$stage5$t_end, dt = cfg$stage5$dt, x0 = x0),
error = function(e) NULL)
if (is.null(sim_lo) || is.null(sim_hi)) {
return(tibble(
sim_ok = FALSE, sim_reason = "simulate_model_error",
bounded_below = NA, bounded_above = NA,
has_cycle_below = NA, has_cycle_above = NA,
amp_below = NA_real_, amp_above = NA_real_,
period_below = NA_real_, period_above = NA_real_,
omega_mean_above = NA_real_,
rF_lo = rF_lo, rF_hi = rF_hi
))
}
sim_lo <- as_tibble(sim_lo)
sim_hi <- as_tibble(sim_hi)
write_csv_safe(sim_lo, file.path(dirs$stage5B, paste0("traj_", id, "_below.csv")))
write_csv_safe(sim_hi, file.path(dirs$stage5B, paste0("traj_", id, "_above.csv")))
met_lo <- cycle_metrics(sim_lo, burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
met_hi <- cycle_metrics(sim_hi, burn_in = cfg$stage5$burn_in,
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
tibble(
sim_ok = TRUE, sim_reason = "ok",
bounded_below = bounded_ok(sim_lo),
bounded_above = bounded_ok(sim_hi),
has_cycle_below = met_lo$has_cycle %||% FALSE,
has_cycle_above = met_hi$has_cycle %||% FALSE,
amp_below = met_lo$amp %||% NA_real_,
amp_above = met_hi$amp %||% NA_real_,
period_below = met_lo$period %||% NA_real_,
period_above = met_hi$period %||% NA_real_,
omega_mean_above = met_hi$omega_mean %||% NA_real_,
rF_lo = rF_lo, rF_hi = rF_hi
)
})
) %>%
unnest(sim)
write_csv_safe(sim_5B, file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"))
# Robustness ring
targets <- sim_5B %>%
filter(sim_ok == TRUE, bounded_above == TRUE, has_cycle_above == TRUE)
robust_5C <- targets %>%
mutate(
robust = pmap(., function(...) {
row <- tibble(...)
rF_test <- as.numeric(row$rF_root)
if (!is.finite(rF_test)) rF_test <- as.numeric(row$rF_seed)
rF_test <- rF_test + cfg$stage5$eps_root
out <- map_dfr(seq_len(cfg$stage5$robust_reps), function(rep_id) {
rowj <- row
for (nm in cfg$stage5$jitter_cols) {
if (nm %in% names(rowj) && is.finite(rowj[[nm]])) {
rowj[[nm]] <- rowj[[nm]] * exp(rnorm(1, 0, cfg$stage5$jitter_sd))
}
}
sim <- tryCatch(call_simulate_model(rowj, rF_sim = rF_test, t_end = cfg$stage5$robust_t_end, dt = cfg$stage5$dt),
error=function(e) NULL)
if (is.null(sim)) {
return(tibble(rep = rep_id, ok = FALSE, bounded = FALSE, has_cycle = FALSE, amp = NA_real_, period = NA_real_))
}
sim <- as_tibble(sim)
met <- cycle_metrics(sim, burn_in = min(cfg$stage5$burn_in, cfg$stage5$robust_t_end/2),
var_min = cfg$stage5$cycle_var_min, amp_min = cfg$stage5$amp_min)
tibble(
rep = rep_id,
ok = TRUE,
bounded = bounded_ok(sim),
has_cycle = met$has_cycle %||% FALSE,
amp = met$amp %||% NA_real_,
period = met$period %||% NA_real_
)
})
tibble(
survival_rate = mean(out$bounded & out$has_cycle, na.rm = TRUE),
bounded_rate  = mean(out$bounded, na.rm = TRUE),
cycle_rate    = mean(out$has_cycle, na.rm = TRUE),
amp_med       = median(out$amp, na.rm = TRUE),
period_med    = median(out$period, na.rm = TRUE)
)
})
) %>%
unnest(robust)
write_csv_safe(robust_5C, file.path(dirs$stage5C, "robustness_summary.csv"))
# Final ranking
final_5D <- sim_5B %>%
left_join(robust_5C %>% select(candidate_id, survival_rate, bounded_rate, cycle_rate, amp_med, period_med),
by = "candidate_id") %>%
mutate(
survival_rate = coalesce(survival_rate, 0),
bounded_rate  = coalesce(bounded_rate, 0),
cycle_rate    = coalesce(cycle_rate, 0),
score_stage5 = 3*survival_rate + 1*bounded_rate + 1*cycle_rate +
0.2*if_else(is.finite(amp_above), pmin(amp_above, 1), 0)
) %>%
arrange(desc(score_stage5))
write_csv_safe(final_5D, file.path(dirs$stage5D, "stage5_final_ranked.csv"))
write_csv_safe(final_5D %>% slice_head(n = 20), file.path(dirs$stage5D, "stage5_top20.csv"))
cat("\nStage 5 complete.\n")
cat("  5A: ", file.path(dirs$stage5A, "stage5A_hopf_certified.csv"), "\n", sep="")
cat("  5B: ", file.path(dirs$stage5B, "stage5B_cycle_metrics.csv"), "\n", sep="")
cat("  5C: ", file.path(dirs$stage5C, "robustness_summary.csv"), "\n", sep="")
cat("  5D: ", file.path(dirs$stage5D, "stage5_final_ranked.csv"), "\n", sep="")
invisible(final_5D)
}
# ============================================================
# 10) RUN PIPELINE (sequential, restart-friendly)
# ============================================================
out1 <- NULL; out2 <- NULL; out3 <- NULL; out4 <- NULL
if (isTRUE(cfg$run$stage1)) {
out1 <- run_stage1(cfg, dirs, par_base)
}
if (isTRUE(cfg$run$stage2)) {
stage1_ok <- if (!is.null(out1)) out1$stage1_ok else {
read_csv(file.path(dirs$stage1, "stage1_backbone.csv"), show_col_types = FALSE) %>% filter(backbone_ok)
}
out2 <- run_stage2(cfg, dirs, par_base, stage1_ok)
}
if (isTRUE(cfg$run$stage3)) {
stage2_ok <- if (!is.null(out2)) out2$stage2_ok else {
read_csv(file.path(dirs$stage2, "stage2_finance_scan.csv"), show_col_types = FALSE) %>% filter(econ_ok)
}
out3 <- run_stage3(cfg, dirs, par_base, stage2_ok)
}
if (isTRUE(cfg$run$stage4)) {
out4 <- run_stage4(cfg, dirs)
}
if (isTRUE(cfg$run$stage5)) {
run_stage5(cfg, dirs)
}
dplyr::last_dplyr_warnings()
dplyr::last_dplyr_warnings()
